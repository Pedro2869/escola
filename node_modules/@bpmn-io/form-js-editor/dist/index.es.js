import { FormFieldRegistry as FormFieldRegistry$1, clone, FormContext, FormRenderContext, FormComponent, FormFields, Default, createFormContainer, createInjector, schemaVersion } from '@bpmn-io/form-js-viewer';
export { schemaVersion } from '@bpmn-io/form-js-viewer';
import Ids from 'ids';
import { isArray, isFunction, isNumber, bind, assign, debounce, forEach, get, isObject, uniqueBy, sortBy, find, set, isUndefined, without, has, isString } from 'min-dash';
import { createContext, render, createElement } from 'preact';
import { useContext, useRef, useState, useEffect, useCallback, useMemo, useLayoutEffect } from 'preact/hooks';
import dragula from 'dragula';
import React from 'preact/compat';
import { jsxs, jsx } from 'preact/jsx-runtime';
import { matches, closest, event, domify, query } from 'min-dom';
import { mutate } from 'array-move';
import classnames from 'classnames';

var FN_REF = '__fn';
var DEFAULT_PRIORITY$3 = 1000;
var slice = Array.prototype.slice;
/**
 * A general purpose event bus.
 *
 * This component is used to communicate across a diagram instance.
 * Other parts of a diagram can use it to listen to and broadcast events.
 *
 *
 * ## Registering for Events
 *
 * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
 * methods to register for events. {@link EventBus#off} can be used to
 * remove event registrations. Listeners receive an instance of {@link Event}
 * as the first argument. It allows them to hook into the event execution.
 *
 * ```javascript
 *
 * // listen for event
 * eventBus.on('foo', function(event) {
 *
 *   // access event type
 *   event.type; // 'foo'
 *
 *   // stop propagation to other listeners
 *   event.stopPropagation();
 *
 *   // prevent event default
 *   event.preventDefault();
 * });
 *
 * // listen for event with custom payload
 * eventBus.on('bar', function(event, payload) {
 *   console.log(payload);
 * });
 *
 * // listen for event returning value
 * eventBus.on('foobar', function(event) {
 *
 *   // stop event propagation + prevent default
 *   return false;
 *
 *   // stop event propagation + return custom result
 *   return {
 *     complex: 'listening result'
 *   };
 * });
 *
 *
 * // listen with custom priority (default=1000, higher is better)
 * eventBus.on('priorityfoo', 1500, function(event) {
 *   console.log('invoked first!');
 * });
 *
 *
 * // listen for event and pass the context (`this`)
 * eventBus.on('foobar', function(event) {
 *   this.foo();
 * }, this);
 * ```
 *
 *
 * ## Emitting Events
 *
 * Events can be emitted via the event bus using {@link EventBus#fire}.
 *
 * ```javascript
 *
 * // false indicates that the default action
 * // was prevented by listeners
 * if (eventBus.fire('foo') === false) {
 *   console.log('default has been prevented!');
 * };
 *
 *
 * // custom args + return value listener
 * eventBus.on('sum', function(event, a, b) {
 *   return a + b;
 * });
 *
 * // you can pass custom arguments + retrieve result values.
 * var sum = eventBus.fire('sum', 1, 2);
 * console.log(sum); // 3
 * ```
 */

function EventBus() {
  this._listeners = {}; // cleanup on destroy on lowest priority to allow
  // message passing until the bitter end

  this.on('diagram.destroy', 1, this._destroy, this);
}
/**
 * Register an event listener for events with the given name.
 *
 * The callback will be invoked with `event, ...additionalArguments`
 * that have been passed to {@link EventBus#fire}.
 *
 * Returning false from a listener will prevent the events default action
 * (if any is specified). To stop an event from being processed further in
 * other listeners execute {@link Event#stopPropagation}.
 *
 * Returning anything but `undefined` from a listener will stop the listener propagation.
 *
 * @param {string|Array<string>} events
 * @param {number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback
 * @param {Object} [that] Pass context (`this`) to the callback
 */

EventBus.prototype.on = function (events, priority, callback, that) {
  events = isArray(events) ? events : [events];

  if (isFunction(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY$3;
  }

  if (!isNumber(priority)) {
    throw new Error('priority must be a number');
  }

  var actualCallback = callback;

  if (that) {
    actualCallback = bind(callback, that); // make sure we remember and are able to remove
    // bound callbacks via {@link #off} using the original
    // callback

    actualCallback[FN_REF] = callback[FN_REF] || callback;
  }

  var self = this;
  events.forEach(function (e) {
    self._addListener(e, {
      priority: priority,
      callback: actualCallback,
      next: null
    });
  });
};
/**
 * Register an event listener that is executed only once.
 *
 * @param {string} event the event name to register for
 * @param {number} [priority=1000] the priority in which this listener is called, larger is higher
 * @param {Function} callback the callback to execute
 * @param {Object} [that] Pass context (`this`) to the callback
 */


EventBus.prototype.once = function (event, priority, callback, that) {
  var self = this;

  if (isFunction(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY$3;
  }

  if (!isNumber(priority)) {
    throw new Error('priority must be a number');
  }

  function wrappedCallback() {
    wrappedCallback.__isTomb = true;
    var result = callback.apply(that, arguments);
    self.off(event, wrappedCallback);
    return result;
  } // make sure we remember and are able to remove
  // bound callbacks via {@link #off} using the original
  // callback


  wrappedCallback[FN_REF] = callback;
  this.on(event, priority, wrappedCallback);
};
/**
 * Removes event listeners by event and callback.
 *
 * If no callback is given, all listeners for a given event name are being removed.
 *
 * @param {string|Array<string>} events
 * @param {Function} [callback]
 */


EventBus.prototype.off = function (events, callback) {
  events = isArray(events) ? events : [events];
  var self = this;
  events.forEach(function (event) {
    self._removeListener(event, callback);
  });
};
/**
 * Create an EventBus event.
 *
 * @param {Object} data
 *
 * @return {Object} event, recognized by the eventBus
 */


EventBus.prototype.createEvent = function (data) {
  var event = new InternalEvent();
  event.init(data);
  return event;
};
/**
 * Fires a named event.
 *
 * @example
 *
 * // fire event by name
 * events.fire('foo');
 *
 * // fire event object with nested type
 * var event = { type: 'foo' };
 * events.fire(event);
 *
 * // fire event with explicit type
 * var event = { x: 10, y: 20 };
 * events.fire('element.moved', event);
 *
 * // pass additional arguments to the event
 * events.on('foo', function(event, bar) {
 *   alert(bar);
 * });
 *
 * events.fire({ type: 'foo' }, 'I am bar!');
 *
 * @param {string} [name] the optional event name
 * @param {Object} [event] the event object
 * @param {...Object} additional arguments to be passed to the callback functions
 *
 * @return {boolean} the events return value, if specified or false if the
 *                   default action was prevented by listeners
 */


EventBus.prototype.fire = function (type, data) {
  var event, firstListener, returnValue, args;
  args = slice.call(arguments);

  if (typeof type === 'object') {
    data = type;
    type = data.type;
  }

  if (!type) {
    throw new Error('no event type specified');
  }

  firstListener = this._listeners[type];

  if (!firstListener) {
    return;
  } // we make sure we fire instances of our home made
  // events here. We wrap them only once, though


  if (data instanceof InternalEvent) {
    // we are fine, we alread have an event
    event = data;
  } else {
    event = this.createEvent(data);
  } // ensure we pass the event as the first parameter


  args[0] = event; // original event type (in case we delegate)

  var originalType = event.type; // update event type before delegation

  if (type !== originalType) {
    event.type = type;
  }

  try {
    returnValue = this._invokeListeners(event, args, firstListener);
  } finally {
    // reset event type after delegation
    if (type !== originalType) {
      event.type = originalType;
    }
  } // set the return value to false if the event default
  // got prevented and no other return value exists


  if (returnValue === undefined && event.defaultPrevented) {
    returnValue = false;
  }

  return returnValue;
};

EventBus.prototype.handleError = function (error) {
  return this.fire('error', {
    error: error
  }) === false;
};

EventBus.prototype._destroy = function () {
  this._listeners = {};
};

EventBus.prototype._invokeListeners = function (event, args, listener) {
  var returnValue;

  while (listener) {
    // handle stopped propagation
    if (event.cancelBubble) {
      break;
    }

    returnValue = this._invokeListener(event, args, listener);
    listener = listener.next;
  }

  return returnValue;
};

EventBus.prototype._invokeListener = function (event, args, listener) {
  var returnValue;

  if (listener.callback.__isTomb) {
    return returnValue;
  }

  try {
    // returning false prevents the default action
    returnValue = invokeFunction(listener.callback, args); // stop propagation on return value

    if (returnValue !== undefined) {
      event.returnValue = returnValue;
      event.stopPropagation();
    } // prevent default on return false


    if (returnValue === false) {
      event.preventDefault();
    }
  } catch (error) {
    if (!this.handleError(error)) {
      console.error('unhandled error in event listener', error);
      throw error;
    }
  }

  return returnValue;
};
/*
 * Add new listener with a certain priority to the list
 * of listeners (for the given event).
 *
 * The semantics of listener registration / listener execution are
 * first register, first serve: New listeners will always be inserted
 * after existing listeners with the same priority.
 *
 * Example: Inserting two listeners with priority 1000 and 1300
 *
 *    * before: [ 1500, 1500, 1000, 1000 ]
 *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]
 *
 * @param {string} event
 * @param {Object} listener { priority, callback }
 */


EventBus.prototype._addListener = function (event, newListener) {
  var listener = this._getListeners(event),
      previousListener; // no prior listeners


  if (!listener) {
    this._setListeners(event, newListener);

    return;
  } // ensure we order listeners by priority from
  // 0 (high) to n > 0 (low)


  while (listener) {
    if (listener.priority < newListener.priority) {
      newListener.next = listener;

      if (previousListener) {
        previousListener.next = newListener;
      } else {
        this._setListeners(event, newListener);
      }

      return;
    }

    previousListener = listener;
    listener = listener.next;
  } // add new listener to back


  previousListener.next = newListener;
};

EventBus.prototype._getListeners = function (name) {
  return this._listeners[name];
};

EventBus.prototype._setListeners = function (name, listener) {
  this._listeners[name] = listener;
};

EventBus.prototype._removeListener = function (event, callback) {
  var listener = this._getListeners(event),
      nextListener,
      previousListener,
      listenerCallback;

  if (!callback) {
    // clear listeners
    this._setListeners(event, null);

    return;
  }

  while (listener) {
    nextListener = listener.next;
    listenerCallback = listener.callback;

    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
      if (previousListener) {
        previousListener.next = nextListener;
      } else {
        // new first listener
        this._setListeners(event, nextListener);
      }
    }

    previousListener = listener;
    listener = nextListener;
  }
};
/**
 * A event that is emitted via the event bus.
 */


function InternalEvent() {}

InternalEvent.prototype.stopPropagation = function () {
  this.cancelBubble = true;
};

InternalEvent.prototype.preventDefault = function () {
  this.defaultPrevented = true;
};

InternalEvent.prototype.init = function (data) {
  assign(this, data || {});
};
/**
 * Invoke function. Be fast...
 *
 * @param {Function} fn
 * @param {Array<Object>} args
 *
 * @return {Any}
 */


function invokeFunction(fn, args) {
  return fn.apply(null, args);
}

/**
 * A factory to create a configurable debouncer.
 *
 * @param {number|boolean} [config=true]
 */

function DebounceFactory(config = true) {
  const timeout = typeof config === 'number' ? config : config ? 300 : 0;

  if (timeout) {
    return fn => debounce(fn, timeout);
  } else {
    return fn => fn;
  }
}
DebounceFactory.$inject = ['config.debounce'];

class FieldFactory {
  /**
   * @constructor
   *
   * @param { import('./FormFieldRegistry').default } formFieldRegistry
   * @param { import('@bpmn-io/form-js-viewer').FormFields } formFields
   */
  constructor(formFieldRegistry, formFields) {
    this._formFieldRegistry = formFieldRegistry;
    this._formFields = formFields;
  }

  create(attrs, applyDefaults = true) {
    const {
      id,
      key,
      type
    } = attrs;

    const fieldDefinition = this._formFields.get(type);

    if (!fieldDefinition) {
      throw new Error(`form field of type <${type}> not supported`);
    }

    if (id && this._formFieldRegistry._ids.assigned(id)) {
      throw new Error(`ID <${id}> already assigned`);
    }

    if (key && this._formFieldRegistry._keys.assigned(key)) {
      throw new Error(`key <${key}> already assigned`);
    }

    const labelAttrs = applyDefaults && fieldDefinition.label ? {
      label: fieldDefinition.label
    } : {};
    const field = fieldDefinition.create({ ...labelAttrs,
      ...attrs
    });

    this._ensureId(field);

    if (fieldDefinition.keyed) {
      this._ensureKey(field, applyDefaults);
    }

    return field;
  }

  _ensureId(field) {
    if (field.id) {
      this._formFieldRegistry._ids.claim(field.id, field);

      return;
    }

    let prefix = 'Field';

    if (field.type === 'default') {
      prefix = 'Form';
    }

    field.id = this._formFieldRegistry._ids.nextPrefixed(`${prefix}_`, field);
  }

  _ensureKey(field, applyDefaults) {
    if (field.key) {
      this._formFieldRegistry._keys.claim(field.key, field);

      return;
    }

    if (applyDefaults) {
      let prefix = 'field';
      field.key = this._formFieldRegistry._keys.nextPrefixed(`${prefix}_`, field);
    }
  }

}
FieldFactory.$inject = ['formFieldRegistry', 'formFields'];

class FormFieldRegistry extends FormFieldRegistry$1 {
  /**
   * Updates a form fields id.
   *
   * @param {Object} formField
   * @param {string} newId
   */
  updateId(formField, newId) {
    this._validateId(newId);

    this._eventBus.fire('formField.updateId', {
      formField,
      newId: newId
    });

    this.remove(formField);
    formField.id = newId;
    this.add(formField); // TODO(nikku): make this a proper object graph so we
    // do not have to deal with IDs this way...

    if ('components' in formField) {
      for (const component of formField.components) {
        component._parent = newId;
      }
    }
  }
  /**
   * Validate the suitability of the given id and signals a problem
   * with an exception.
   *
   * @param {string} id
   *
   * @throws {Error} if id is empty or already assigned
   */


  _validateId(id) {
    if (!id) {
      throw new Error('formField must have an id');
    }

    if (this.get(id)) {
      throw new Error('formField with id ' + id + ' already added');
    }
  }

}

class Importer {
  /**
   * @constructor
   * @param { import('../core/FormFieldRegistry').default } formFieldRegistry
   * @param { import('../core/FieldFactory').default } fieldFactory
   */
  constructor(formFieldRegistry, fieldFactory) {
    this._formFieldRegistry = formFieldRegistry;
    this._fieldFactory = fieldFactory;
  }
  /**
   * Import schema creating fields, attaching additional
   * information to each field and adding fields to the
   * field registry.
   *
   * Additional information attached:
   *
   *   * `id` (unless present)
   *   * `_parent`
   *   * `_path`
   *
   * @param {any} schema
   *
   * @typedef {{ warnings: Error[], schema: any }} ImportResult
   * @returns {ImportResult}
   */


  importSchema(schema) {
    // TODO: Add warnings
    const warnings = [];

    try {
      const importedSchema = this.importFormField(clone(schema));
      return {
        schema: importedSchema,
        warnings
      };
    } catch (err) {
      err.warnings = warnings;
      throw err;
    }
  }
  /**
   * @param {{[x: string]: any}} fieldAttrs
   * @param {String} [parentId]
   * @param {number} [index]
   *
   * @return {any} field
   */


  importFormField(fieldAttrs, parentId, index) {
    const {
      components,
      id,
      key
    } = fieldAttrs;
    let parent, path;

    if (parentId) {
      parent = this._formFieldRegistry.get(parentId);
    } // validate <id> uniqueness


    if (id && this._formFieldRegistry._ids.assigned(id)) {
      throw new Error(`form field with id <${id}> already exists`);
    } // validate <key> uniqueness


    if (key && this._formFieldRegistry._keys.assigned(key)) {
      throw new Error(`form field with key <${key}> already exists`);
    } // set form field path


    path = parent ? [...parent._path, 'components', index] : [];

    const field = this._fieldFactory.create({ ...fieldAttrs,
      _path: path,
      _parent: parent && parent.id
    }, false);

    this._formFieldRegistry.add(field);

    if (components) {
      field.components = this.importFormFields(components, field.id);
    }

    return field;
  }
  /**
   * @param {Array<any>} components
   * @param {string} parentId
   *
   * @return {Array<any>} imported components
   */


  importFormFields(components, parentId) {
    return components.map((component, index) => {
      return this.importFormField(component, parentId, index);
    });
  }

}
Importer.$inject = ['formFieldRegistry', 'fieldFactory'];

var importModule = {
  importer: ['type', Importer]
};

const DragAndDropContext = createContext({
  drake: null
});

/**
 * @param {string} type
 * @param {boolean} [strict]
 *
 * @returns {any}
 */

function getService$1(type, strict) {}

const FormEditorContext = createContext({
  getService: getService$1
});

function useService$1 (type, strict) {
  const {
    getService
  } = useContext(FormEditorContext);
  return getService(type, strict);
}

function _extends$b() { _extends$b = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$b.apply(this, arguments); }
var ListDeleteIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$b({
  xmlns: "http://www.w3.org/2000/svg",
  width: "11",
  height: "14"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M10 4v8c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2V4h9zM8 6H3v4.8c0 .66.5 1.2 1.111 1.2H6.89C7.5 12 8 11.46 8 10.8V6zm3-5H8.5l-1-1h-4l-1 1H0v1.5h11V1z"
})));

function _extends$a() { _extends$a = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$a.apply(this, arguments); }
var ButtonIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$a({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M45 17a3 3 0 013 3v14a3 3 0 01-3 3H9a3 3 0 01-3-3V20a3 3 0 013-3h36zm-9 8.889H18v2.222h18V25.89z"
})));

function _extends$9() { _extends$9 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$9.apply(this, arguments); }
var CheckboxIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$9({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M34 18H20a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V20a2 2 0 00-2-2zm-9 14l-5-5 1.41-1.41L25 29.17l7.59-7.59L34 23l-9 9z"
})));

function _extends$8() { _extends$8 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$8.apply(this, arguments); }
var ChecklistIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$8({
  width: "54",
  height: "54",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M19 24h-6v6h6v-6zm-6-2a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2v-6a2 2 0 00-2-2h-6zm6 18h-6v6h6v-6zm-6-2a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2v-6a2 2 0 00-2-2h-6zm6-30h-6v6h6V8zm-6-2a2 2 0 00-2 2v6a2 2 0 002 2h6a2 2 0 002-2V8a2 2 0 00-2-2h-6z",
  fill: "#22242A"
}), /*#__PURE__*/React.createElement("path", {
  d: "M26 26a1 1 0 011-1h15a1 1 0 011 1v2a1 1 0 01-1 1H27a1 1 0 01-1-1v-2zm0 16a1 1 0 011-1h15a1 1 0 011 1v2a1 1 0 01-1 1H27a1 1 0 01-1-1v-2zm0-32a1 1 0 011-1h15a1 1 0 011 1v2a1 1 0 01-1 1H27a1 1 0 01-1-1v-2z",
  fill: "#22242A"
})));

function _extends$7() { _extends$7 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$7.apply(this, arguments); }
var TaglistIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$7({
  width: "54",
  height: "54",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M45 16a3 3 0 013 3v16a3 3 0 01-3 3H9a3 3 0 01-3-3V19a3 3 0 013-3h36zm0 2H9a1 1 0 00-1 1v16a1 1 0 001 1h36a1 1 0 001-1V19a1 1 0 00-1-1z",
  fill: "#000"
}), /*#__PURE__*/React.createElement("path", {
  d: "M11 22a1 1 0 011-1h19a1 1 0 011 1v10a1 1 0 01-1 1H12a1 1 0 01-1-1V22z",
  fill: "#505562"
})));

function _extends$6() { _extends$6 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }
var FormIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$6({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("rect", {
  x: "15",
  y: "17",
  width: "24",
  height: "4",
  rx: "1"
}), /*#__PURE__*/React.createElement("rect", {
  x: "15",
  y: "25",
  width: "24",
  height: "4",
  rx: "1"
}), /*#__PURE__*/React.createElement("rect", {
  x: "15",
  y: "33",
  width: "13",
  height: "4",
  rx: "1"
})));

function _extends$5() { _extends$5 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }
var ColumnsIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$5({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M8 33v5a1 1 0 001 1h4v2H9a3 3 0 01-3-3v-5h2zm18 6v2H15v-2h11zm13 0v2H28v-2h11zm9-6v5a3 3 0 01-3 3h-4v-2h4a1 1 0 00.993-.883L46 38v-5h2zM8 22v9H6v-9h2zm40 0v9h-2v-9h2zm-35-9v2H9a1 1 0 00-.993.883L8 16v4H6v-4a3 3 0 013-3h4zm32 0a3 3 0 013 3v4h-2v-4a1 1 0 00-.883-.993L45 15h-4v-2h4zm-6 0v2H28v-2h11zm-13 0v2H15v-2h11z"
})));

function _extends$4() { _extends$4 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }
var NumberIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$4({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M45 16a3 3 0 013 3v16a3 3 0 01-3 3H9a3 3 0 01-3-3V19a3 3 0 013-3h36zm0 2H9a1 1 0 00-1 1v16a1 1 0 001 1h36a1 1 0 001-1V19a1 1 0 00-1-1zM35 28.444h7l-3.5 4-3.5-4zM35 26h7l-3.5-4-3.5 4z"
})));

function _extends$3() { _extends$3 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
var RadioIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$3({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M27 22c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
})));

function _extends$2() { _extends$2 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }
var SelectIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$2({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M45 16a3 3 0 013 3v16a3 3 0 01-3 3H9a3 3 0 01-3-3V19a3 3 0 013-3h36zm0 2H9a1 1 0 00-1 1v16a1 1 0 001 1h36a1 1 0 001-1V19a1 1 0 00-1-1zm-12 7h9l-4.5 6-4.5-6z"
})));

function _extends$1() { _extends$1 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
var TextIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends$1({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M20.58 33.77h-3l-1.18-3.08H11l-1.1 3.08H7l5.27-13.54h2.89zm-5-5.36l-1.86-5-1.83 5zM22 20.23h5.41a15.47 15.47 0 012.4.14 3.42 3.42 0 011.41.55 3.47 3.47 0 011 1.14 3 3 0 01.42 1.58 3.26 3.26 0 01-1.91 2.94 3.63 3.63 0 011.91 1.22 3.28 3.28 0 01.66 2 4 4 0 01-.43 1.8 3.63 3.63 0 01-1.09 1.4 3.89 3.89 0 01-1.83.65q-.69.07-3.3.09H22zm2.73 2.25v3.13h3.8a1.79 1.79 0 001.1-.49 1.41 1.41 0 00.41-1 1.49 1.49 0 00-.35-1 1.54 1.54 0 00-1-.48c-.27 0-1.05-.05-2.34-.05zm0 5.39v3.62h2.57a11.52 11.52 0 001.88-.09 1.65 1.65 0 001-.54 1.6 1.6 0 00.38-1.14 1.75 1.75 0 00-.29-1 1.69 1.69 0 00-.86-.62 9.28 9.28 0 00-2.41-.23zM44.35 28.79l2.65.84a5.94 5.94 0 01-2 3.29A5.74 5.74 0 0141.38 34a5.87 5.87 0 01-4.44-1.84 7.09 7.09 0 01-1.73-5A7.43 7.43 0 0137 21.87 6 6 0 0141.54 20a5.64 5.64 0 014 1.47A5.33 5.33 0 0147 24l-2.7.65a2.8 2.8 0 00-2.86-2.27A3.09 3.09 0 0039 23.42a5.31 5.31 0 00-.93 3.5 5.62 5.62 0 00.93 3.65 3 3 0 002.4 1.09 2.72 2.72 0 001.82-.66 4 4 0 001.13-2.21z"
})));

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var TextfieldIcon = (({
  styles = {},
  ...props
}) => /*#__PURE__*/React.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  width: "54",
  height: "54"
}, props), /*#__PURE__*/React.createElement("path", {
  fillRule: "evenodd",
  d: "M45 16a3 3 0 013 3v16a3 3 0 01-3 3H9a3 3 0 01-3-3V19a3 3 0 013-3h36zm0 2H9a1 1 0 00-1 1v16a1 1 0 001 1h36a1 1 0 001-1V19a1 1 0 00-1-1zm-32 4v10h-2V22h2z"
})));

const iconsByType = {
  button: ButtonIcon,
  checkbox: CheckboxIcon,
  checklist: ChecklistIcon,
  columns: ColumnsIcon,
  number: NumberIcon,
  radio: RadioIcon,
  select: SelectIcon,
  taglist: TaglistIcon,
  text: TextIcon,
  textfield: TextfieldIcon,
  default: FormIcon
};

function ContextPad(props) {
  if (!props.children) {
    return null;
  }

  return jsx("div", {
    class: "fjs-context-pad",
    children: props.children
  });
}

function Empty(props) {
  return null;
}

function Element(props) {
  const eventBus = useService$1('eventBus'),
        formEditor = useService$1('formEditor'),
        formFieldRegistry = useService$1('formFieldRegistry'),
        modeling = useService$1('modeling'),
        selection = useService$1('selection');
  const {
    field
  } = props;
  const {
    id,
    type
  } = field;
  const ref = useRef();

  function scrollIntoView({
    selection
  }) {
    if (!selection || selection.id !== id || !ref.current) {
      return;
    }

    const elementBounds = ref.current.getBoundingClientRect(),
          containerBounds = formEditor._container.getBoundingClientRect();

    if (elementBounds.top < 0 || elementBounds.top > containerBounds.bottom) {
      ref.current.scrollIntoView();
    }
  }

  useEffect(() => {
    eventBus.on('selection.changed', scrollIntoView);
    return () => eventBus.off('selection.changed', scrollIntoView);
  }, [id]);

  function onClick(event) {
    event.stopPropagation();
    selection.toggle(field);
  }

  const classes = ['fjs-element'];

  if (props.class) {
    classes.push(...props.class.split(' '));
  }

  if (selection.isSelected(field)) {
    classes.push('fjs-editor-selected');
  }

  const onRemove = event => {
    event.stopPropagation();
    const parentField = formFieldRegistry.get(field._parent);
    const index = getFormFieldIndex(parentField, field);
    modeling.removeFormField(field, parentField, index);
  };

  return jsxs("div", {
    class: classes.join(' '),
    "data-id": id,
    "data-field-type": type,
    onClick: onClick,
    ref: ref,
    children: [jsx(ContextPad, {
      children: selection.isSelected(field) && field.type !== 'default' ? jsx("button", {
        class: "fjs-context-pad-item",
        onClick: onRemove,
        children: jsx(ListDeleteIcon, {})
      }) : null
    }), props.children]
  });
}

function Children(props) {
  const {
    field
  } = props;
  const {
    id
  } = field;
  const classes = ['fjs-children', 'fjs-drag-container'];

  if (props.class) {
    classes.push(...props.class.split(' '));
  }

  return jsx("div", {
    class: classes.join(' '),
    "data-id": id,
    children: props.children
  });
}

function FormEditor$1(props) {
  const eventBus = useService$1('eventBus'),
        formEditor = useService$1('formEditor'),
        formFieldRegistry = useService$1('formFieldRegistry'),
        injector = useService$1('injector'),
        modeling = useService$1('modeling'),
        selection = useService$1('selection'),
        palette = useService$1('palette'),
        paletteConfig = useService$1('config.palette'),
        propertiesPanel = useService$1('propertiesPanel'),
        propertiesPanelConfig = useService$1('config.propertiesPanel');

  const {
    schema
  } = formEditor._getState();

  const paletteRef = useRef(null);
  const propertiesPanelRef = useRef(null);
  const [, setSelection] = useState(schema);
  useEffect(() => {
    function handleSelectionChanged(event) {
      setSelection(event.selection || schema);
    }

    eventBus.on('selection.changed', handleSelectionChanged);
    setSelection(selection.get() || schema);
    return () => {
      eventBus.off('selection.changed', handleSelectionChanged);
    };
  }, [schema, selection]);
  const [drake, setDrake] = useState(null);
  const dragAndDropContext = {
    drake
  };
  useEffect(() => {
    const createDragulaInstance = () => {
      const dragulaInstance = dragula({
        isContainer(el) {
          return el.classList.contains('fjs-drag-container');
        },

        copy(el) {
          return el.classList.contains('fjs-drag-copy');
        },

        accepts(el, target) {
          return !target.classList.contains('fjs-no-drop');
        },

        slideFactorX: 10,
        slideFactorY: 5
      });
      dragulaInstance.on('drop', (el, target, source, sibling) => {
        dragulaInstance.remove();

        if (!target) {
          return;
        }

        const targetFormField = formFieldRegistry.get(target.dataset.id);
        const siblingFormField = sibling && formFieldRegistry.get(sibling.dataset.id),
              targetIndex = siblingFormField ? getFormFieldIndex(targetFormField, siblingFormField) : targetFormField.components.length;

        if (source.classList.contains('fjs-palette-fields')) {
          const type = el.dataset.fieldType;
          modeling.addFormField({
            type
          }, targetFormField, targetIndex);
        } else {
          const formField = formFieldRegistry.get(el.dataset.id),
                sourceFormField = formFieldRegistry.get(source.dataset.id),
                sourceIndex = getFormFieldIndex(sourceFormField, formField);
          modeling.moveFormField(formField, sourceFormField, targetFormField, sourceIndex, targetIndex);
        }
      });
      eventBus.fire('dragula.created');
      setDrake(dragulaInstance);
      return dragulaInstance;
    };

    let dragulaInstance = createDragulaInstance();

    const onDetach = () => {
      if (dragulaInstance) {
        dragulaInstance.destroy();
        eventBus.fire('dragula.destroyed');
      }
    };

    const onAttach = () => {
      onDetach();
      dragulaInstance = createDragulaInstance();
    };

    eventBus.on('attach', onAttach);
    eventBus.on('detach', onDetach);
    return () => {
      onDetach();
      eventBus.off('attach', onAttach);
      eventBus.off('detach', onDetach);
    };
  }, []); // fire event after render to notify interested parties

  useEffect(() => {
    eventBus.fire('formEditor.rendered');
  }, []);
  const formRenderContext = {
    Children,
    Element,
    Empty
  };
  const formContext = {
    getService(type, strict = true) {
      // TODO(philippfromme): clean up
      if (type === 'formFieldRegistry') {
        return new Map();
      } else if (type === 'form') {
        return {
          _getState() {
            return {
              data: {},
              errors: {},
              properties: {
                readOnly: true
              },
              schema
            };
          }

        };
      }

      return injector.get(type, strict);
    },

    formId: formEditor._id
  };
  const onSubmit = useCallback(() => {}, []);
  const onReset = useCallback(() => {}, []); // attach default palette

  const hasDefaultPalette = defaultPalette(paletteConfig);
  useEffect(() => {
    if (hasDefaultPalette) {
      palette.attachTo(paletteRef.current);
    }
  }, [palette, paletteRef, hasDefaultPalette]); // attach default properties panel

  const hasDefaultPropertiesPanel = defaultPropertiesPanel(propertiesPanelConfig);
  useEffect(() => {
    if (hasDefaultPropertiesPanel) {
      propertiesPanel.attachTo(propertiesPanelRef.current);
    }
  }, [propertiesPanelRef, propertiesPanel, hasDefaultPropertiesPanel]);
  return jsxs("div", {
    class: "fjs-form-editor",
    children: [jsxs(DragAndDropContext.Provider, {
      value: dragAndDropContext,
      children: [hasDefaultPalette && jsx("div", {
        class: "fjs-editor-palette-container",
        ref: paletteRef
      }), jsx("div", {
        class: "fjs-form-container",
        children: jsx(FormContext.Provider, {
          value: formContext,
          children: jsx(FormRenderContext.Provider, {
            value: formRenderContext,
            children: jsx(FormComponent, {
              onSubmit: onSubmit,
              onReset: onReset
            })
          })
        })
      }), jsx(CreatePreview, {})]
    }), hasDefaultPropertiesPanel && jsx("div", {
      class: "fjs-editor-properties-container",
      ref: propertiesPanelRef
    })]
  });
}

function getFormFieldIndex(parent, formField) {
  let fieldFormIndex = parent.components.length;
  parent.components.forEach(({
    id
  }, index) => {
    if (id === formField.id) {
      fieldFormIndex = index;
    }
  });
  return fieldFormIndex;
}

function CreatePreview(props) {
  const {
    drake
  } = useContext(DragAndDropContext);

  function handleCloned(clone, original, type) {
    const fieldType = clone.dataset.fieldType;
    const Icon = iconsByType[fieldType];

    if (fieldType) {
      clone.innerHTML = '';
      clone.class = 'gu-mirror';
      render(jsx(Icon, {}), clone);
    }
  }

  useEffect(() => {
    if (!drake) {
      return;
    }

    drake.on('cloned', handleCloned);
    return () => drake.off('cloned', handleCloned);
  }, [drake]);
  return null;
} // helper //////


function defaultPalette(paletteConfig) {
  return !(paletteConfig && paletteConfig.parent);
}

function defaultPropertiesPanel(propertiesPanelConfig) {
  return !(propertiesPanelConfig && propertiesPanelConfig.parent);
}

class Renderer {
  constructor(renderConfig, eventBus, formEditor, injector) {
    const {
      container,
      compact = false
    } = renderConfig;

    const App = () => {
      const [state, setState] = useState(formEditor._getState());
      const formEditorContext = {
        getService(type, strict = true) {
          return injector.get(type, strict);
        }

      };
      formEditor.on('changed', newState => {
        setState(newState);
      });
      const {
        schema
      } = state;

      if (!schema) {
        return null;
      }

      return jsx("div", {
        class: `fjs-container fjs-editor-container ${compact ? 'fjs-editor-compact' : ''}`,
        children: jsx(FormEditorContext.Provider, {
          value: formEditorContext,
          children: jsx(FormEditor$1, {})
        })
      });
    };

    eventBus.on('form.init', () => {
      render(jsx(App, {}), container);
    });
    eventBus.on('form.destroy', () => {
      render(null, container);
    });
  }

}
Renderer.$inject = ['config.renderer', 'eventBus', 'formEditor', 'injector'];

var renderModule = {
  __init__: ['formFields', 'renderer'],
  formFields: ['type', FormFields],
  renderer: ['type', Renderer]
};

var core = {
  __depends__: [importModule, renderModule],
  eventBus: ['type', EventBus],
  formFieldRegistry: ['type', FormFieldRegistry],
  fieldFactory: ['type', FieldFactory],
  debounce: ['factory', DebounceFactory]
};

var NOT_REGISTERED_ERROR = 'is not a registered action',
    IS_REGISTERED_ERROR = 'is already registered';
/**
 * An interface that provides access to modeling actions by decoupling
 * the one who requests the action to be triggered and the trigger itself.
 *
 * It's possible to add new actions by registering them with ´registerAction´
 * and likewise unregister existing ones with ´unregisterAction´.
 *
 *
 * ## Life-Cycle and configuration
 *
 * The editor actions will wait for diagram initialization before
 * registering default actions _and_ firing an `editorActions.init` event.
 *
 * Interested parties may listen to the `editorActions.init` event with
 * low priority to check, which actions got registered. Other components
 * may use the event to register their own actions via `registerAction`.
 *
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */

function EditorActions(eventBus, injector) {
  // initialize actions
  this._actions = {};
  var self = this;
  eventBus.on('diagram.init', function () {
    // all diagram modules got loaded; check which ones
    // are available and register the respective default actions
    self._registerDefaultActions(injector); // ask interested parties to register available editor
    // actions on diagram initialization


    eventBus.fire('editorActions.init', {
      editorActions: self
    });
  });
}
EditorActions.$inject = ['eventBus', 'injector'];
/**
 * Register default actions.
 *
 * @param {Injector} injector
 */

EditorActions.prototype._registerDefaultActions = function (injector) {
  // (1) retrieve optional components to integrate with
  var commandStack = injector.get('commandStack', false);
  var modeling = injector.get('modeling', false);
  var selection = injector.get('selection', false);
  var zoomScroll = injector.get('zoomScroll', false);
  var copyPaste = injector.get('copyPaste', false);
  var canvas = injector.get('canvas', false);
  var rules = injector.get('rules', false);
  var keyboardMove = injector.get('keyboardMove', false);
  var keyboardMoveSelection = injector.get('keyboardMoveSelection', false); // (2) check components and register actions

  if (commandStack) {
    this.register('undo', function () {
      commandStack.undo();
    });
    this.register('redo', function () {
      commandStack.redo();
    });
  }

  if (copyPaste && selection) {
    this.register('copy', function () {
      var selectedElements = selection.get();
      copyPaste.copy(selectedElements);
    });
  }

  if (copyPaste) {
    this.register('paste', function () {
      copyPaste.paste();
    });
  }

  if (zoomScroll) {
    this.register('stepZoom', function (opts) {
      zoomScroll.stepZoom(opts.value);
    });
  }

  if (canvas) {
    this.register('zoom', function (opts) {
      canvas.zoom(opts.value);
    });
  }

  if (modeling && selection && rules) {
    this.register('removeSelection', function () {
      var selectedElements = selection.get();

      if (!selectedElements.length) {
        return;
      }

      var allowed = rules.allowed('elements.delete', {
        elements: selectedElements
      }),
          removableElements;

      if (allowed === false) {
        return;
      } else if (isArray(allowed)) {
        removableElements = allowed;
      } else {
        removableElements = selectedElements;
      }

      if (removableElements.length) {
        modeling.removeElements(removableElements.slice());
      }
    });
  }

  if (keyboardMove) {
    this.register('moveCanvas', function (opts) {
      keyboardMove.moveCanvas(opts);
    });
  }

  if (keyboardMoveSelection) {
    this.register('moveSelection', function (opts) {
      keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
    });
  }
};
/**
 * Triggers a registered action
 *
 * @param  {string} action
 * @param  {Object} opts
 *
 * @return {Unknown} Returns what the registered listener returns
 */


EditorActions.prototype.trigger = function (action, opts) {
  if (!this._actions[action]) {
    throw error(action, NOT_REGISTERED_ERROR);
  }

  return this._actions[action](opts);
};
/**
 * Registers a collections of actions.
 * The key of the object will be the name of the action.
 *
 * @example
 * ´´´
 * var actions = {
 *   spaceTool: function() {
 *     spaceTool.activateSelection();
 *   },
 *   lassoTool: function() {
 *     lassoTool.activateSelection();
 *   }
 * ];
 *
 * editorActions.register(actions);
 *
 * editorActions.isRegistered('spaceTool'); // true
 * ´´´
 *
 * @param  {Object} actions
 */


EditorActions.prototype.register = function (actions, listener) {
  var self = this;

  if (typeof actions === 'string') {
    return this._registerAction(actions, listener);
  }

  forEach(actions, function (listener, action) {
    self._registerAction(action, listener);
  });
};
/**
 * Registers a listener to an action key
 *
 * @param  {string} action
 * @param  {Function} listener
 */


EditorActions.prototype._registerAction = function (action, listener) {
  if (this.isRegistered(action)) {
    throw error(action, IS_REGISTERED_ERROR);
  }

  this._actions[action] = listener;
};
/**
 * Unregister an existing action
 *
 * @param {string} action
 */


EditorActions.prototype.unregister = function (action) {
  if (!this.isRegistered(action)) {
    throw error(action, NOT_REGISTERED_ERROR);
  }

  this._actions[action] = undefined;
};
/**
 * Returns the number of actions that are currently registered
 *
 * @return {number}
 */


EditorActions.prototype.getActions = function () {
  return Object.keys(this._actions);
};
/**
 * Checks wether the given action is registered
 *
 * @param {string} action
 *
 * @return {boolean}
 */


EditorActions.prototype.isRegistered = function (action) {
  return !!this._actions[action];
};

function error(action, message) {
  return new Error(action + ' ' + message);
}

var EditorActionsModule$1 = {
  __init__: ['editorActions'],
  editorActions: ['type', EditorActions]
};

class FormEditorActions extends EditorActions {
  constructor(eventBus, injector) {
    super(eventBus, injector);
    eventBus.on('form.init', () => {
      this._registerDefaultActions(injector);

      eventBus.fire('editorActions.init', {
        editorActions: this
      });
    });
  }

  _registerDefaultActions(injector) {
    const commandStack = injector.get('commandStack', false),
          formFieldRegistry = injector.get('formFieldRegistry', false),
          selection = injector.get('selection', false);

    if (commandStack) {
      // @ts-ignore
      this.register('undo', () => {
        commandStack.undo();
      }); // @ts-ignore

      this.register('redo', () => {
        commandStack.redo();
      });
    }

    if (formFieldRegistry && selection) {
      // @ts-ignore
      this.register('selectFormField', (options = {}) => {
        const {
          id
        } = options;

        if (!id) {
          return;
        }

        const formField = formFieldRegistry.get(id);

        if (formField) {
          selection.set(formField);
        }
      });
    }
  }

}
FormEditorActions.$inject = ['eventBus', 'injector'];

var EditorActionsModule = {
  __depends__: [EditorActionsModule$1],
  editorActions: ['type', FormEditorActions]
};

/**
 * Returns true if event was triggered with any modifier
 * @param {KeyboardEvent} event
 */

function hasModifier(event) {
  return event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;
}
/**
 * @param {KeyboardEvent} event
 */

function isCmd(event) {
  // ensure we don't react to AltGr
  // (mapped to CTRL + ALT)
  if (event.altKey) {
    return false;
  }

  return event.ctrlKey || event.metaKey;
}
/**
 * Checks if key pressed is one of provided keys.
 *
 * @param {string|Array<string>} keys
 * @param {KeyboardEvent} event
 */

function isKey(keys, event) {
  keys = isArray(keys) ? keys : [keys];
  return keys.indexOf(event.key) !== -1 || keys.indexOf(event.keyCode) !== -1;
}
/**
 * @param {KeyboardEvent} event
 */

function isShift(event) {
  return event.shiftKey;
}

var KEYDOWN_EVENT = 'keyboard.keydown',
    KEYUP_EVENT = 'keyboard.keyup';
var HANDLE_MODIFIER_ATTRIBUTE = 'input-handle-modified-keys';
var DEFAULT_PRIORITY$2 = 1000;
/**
 * A keyboard abstraction that may be activated and
 * deactivated by users at will, consuming key events
 * and triggering diagram actions.
 *
 * For keys pressed down, keyboard fires `keyboard.keydown` event.
 * The event context contains one field which is `KeyboardEvent` event.
 *
 * The implementation fires the following key events that allow
 * other components to hook into key handling:
 *
 *  - keyboard.bind
 *  - keyboard.unbind
 *  - keyboard.init
 *  - keyboard.destroy
 *
 * All events contain one field which is node.
 *
 * A default binding for the keyboard may be specified via the
 * `keyboard.bindTo` configuration option.
 *
 * @param {Config} config
 * @param {EventBus} eventBus
 */

function Keyboard(config, eventBus) {
  var self = this;
  this._config = config || {};
  this._eventBus = eventBus;
  this._keydownHandler = this._keydownHandler.bind(this);
  this._keyupHandler = this._keyupHandler.bind(this); // properly clean dom registrations

  eventBus.on('diagram.destroy', function () {
    self._fire('destroy');

    self.unbind();
  });
  eventBus.on('diagram.init', function () {
    self._fire('init');
  });
  eventBus.on('attach', function () {
    if (config && config.bindTo) {
      self.bind(config.bindTo);
    }
  });
  eventBus.on('detach', function () {
    self.unbind();
  });
}
Keyboard.$inject = ['config.keyboard', 'eventBus'];

Keyboard.prototype._keydownHandler = function (event) {
  this._keyHandler(event, KEYDOWN_EVENT);
};

Keyboard.prototype._keyupHandler = function (event) {
  this._keyHandler(event, KEYUP_EVENT);
};

Keyboard.prototype._keyHandler = function (event, type) {
  var eventBusResult;

  if (this._isEventIgnored(event)) {
    return;
  }

  var context = {
    keyEvent: event
  };
  eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);

  if (eventBusResult) {
    event.preventDefault();
  }
};

Keyboard.prototype._isEventIgnored = function (event) {
  return isInput(event.target) && this._isModifiedKeyIgnored(event);
};

Keyboard.prototype._isModifiedKeyIgnored = function (event) {
  if (!isCmd(event)) {
    return true;
  }

  var allowedModifiers = this._getAllowedModifiers(event.target);

  return !allowedModifiers.includes(event.key);
};

Keyboard.prototype._getAllowedModifiers = function (element) {
  var modifierContainer = closest(element, '[' + HANDLE_MODIFIER_ATTRIBUTE + ']', true);

  if (!modifierContainer || this._node && !this._node.contains(modifierContainer)) {
    return [];
  }

  return modifierContainer.getAttribute(HANDLE_MODIFIER_ATTRIBUTE).split(',');
};

Keyboard.prototype.bind = function (node) {
  // make sure that the keyboard is only bound once to the DOM
  this.unbind();
  this._node = node; // bind key events

  event.bind(node, 'keydown', this._keydownHandler, true);
  event.bind(node, 'keyup', this._keyupHandler, true);

  this._fire('bind');
};

Keyboard.prototype.getBinding = function () {
  return this._node;
};

Keyboard.prototype.unbind = function () {
  var node = this._node;

  if (node) {
    this._fire('unbind'); // unbind key events


    event.unbind(node, 'keydown', this._keydownHandler, true);
    event.unbind(node, 'keyup', this._keyupHandler, true);
  }

  this._node = null;
};

Keyboard.prototype._fire = function (event) {
  this._eventBus.fire('keyboard.' + event, {
    node: this._node
  });
};
/**
 * Add a listener function that is notified with `KeyboardEvent` whenever
 * the keyboard is bound and the user presses a key. If no priority is
 * provided, the default value of 1000 is used.
 *
 * @param {number} [priority]
 * @param {Function} listener
 * @param {string} type
 */


Keyboard.prototype.addListener = function (priority, listener, type) {
  if (isFunction(priority)) {
    type = listener;
    listener = priority;
    priority = DEFAULT_PRIORITY$2;
  }

  this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);
};

Keyboard.prototype.removeListener = function (listener, type) {
  this._eventBus.off(type || KEYDOWN_EVENT, listener);
};

Keyboard.prototype.hasModifier = hasModifier;
Keyboard.prototype.isCmd = isCmd;
Keyboard.prototype.isShift = isShift;
Keyboard.prototype.isKey = isKey; // helpers ///////

function isInput(target) {
  return target && (matches(target, 'input, textarea') || target.contentEditable === 'true');
}

var LOW_PRIORITY$1 = 500;
var KEYCODE_C = 67;
var KEYCODE_V = 86;
var KEYCODE_Y = 89;
var KEYCODE_Z = 90;
var KEYS_COPY = ['c', 'C', KEYCODE_C];
var KEYS_PASTE = ['v', 'V', KEYCODE_V];
var KEYS_REDO = ['y', 'Y', KEYCODE_Y];
var KEYS_UNDO = ['z', 'Z', KEYCODE_Z];
/**
 * Adds default keyboard bindings.
 *
 * This does not pull in any features will bind only actions that
 * have previously been registered against the editorActions component.
 *
 * @param {EventBus} eventBus
 * @param {Keyboard} keyboard
 */

function KeyboardBindings(eventBus, keyboard) {
  var self = this;
  eventBus.on('editorActions.init', LOW_PRIORITY$1, function (event) {
    var editorActions = event.editorActions;
    self.registerBindings(keyboard, editorActions);
  });
}
KeyboardBindings.$inject = ['eventBus', 'keyboard'];
/**
 * Register available keyboard bindings.
 *
 * @param {Keyboard} keyboard
 * @param {EditorActions} editorActions
 */

KeyboardBindings.prototype.registerBindings = function (keyboard, editorActions) {
  /**
   * Add keyboard binding if respective editor action
   * is registered.
   *
   * @param {string} action name
   * @param {Function} fn that implements the key binding
   */
  function addListener(action, fn) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  } // undo
  // (CTRL|CMD) + Z


  addListener('undo', function (context) {
    var event = context.keyEvent;

    if (isCmd(event) && !isShift(event) && isKey(KEYS_UNDO, event)) {
      editorActions.trigger('undo');
      return true;
    }
  }); // redo
  // CTRL + Y
  // CMD + SHIFT + Z

  addListener('redo', function (context) {
    var event = context.keyEvent;

    if (isCmd(event) && (isKey(KEYS_REDO, event) || isKey(KEYS_UNDO, event) && isShift(event))) {
      editorActions.trigger('redo');
      return true;
    }
  }); // copy
  // CTRL/CMD + C

  addListener('copy', function (context) {
    var event = context.keyEvent;

    if (isCmd(event) && isKey(KEYS_COPY, event)) {
      editorActions.trigger('copy');
      return true;
    }
  }); // paste
  // CTRL/CMD + V

  addListener('paste', function (context) {
    var event = context.keyEvent;

    if (isCmd(event) && isKey(KEYS_PASTE, event)) {
      editorActions.trigger('paste');
      return true;
    }
  }); // zoom in one step
  // CTRL/CMD + +

  addListener('stepZoom', function (context) {
    var event = context.keyEvent; // quirk: it has to be triggered by `=` as well to work on international keyboard layout
    // cf: https://github.com/bpmn-io/bpmn-js/issues/1362#issuecomment-722989754

    if (isKey(['+', 'Add', '='], event) && isCmd(event)) {
      editorActions.trigger('stepZoom', {
        value: 1
      });
      return true;
    }
  }); // zoom out one step
  // CTRL + -

  addListener('stepZoom', function (context) {
    var event = context.keyEvent;

    if (isKey(['-', 'Subtract'], event) && isCmd(event)) {
      editorActions.trigger('stepZoom', {
        value: -1
      });
      return true;
    }
  }); // zoom to the default level
  // CTRL + 0

  addListener('zoom', function (context) {
    var event = context.keyEvent;

    if (isKey('0', event) && isCmd(event)) {
      editorActions.trigger('zoom', {
        value: 1
      });
      return true;
    }
  }); // delete selected element
  // DEL

  addListener('removeSelection', function (context) {
    var event = context.keyEvent;

    if (isKey(['Backspace', 'Delete', 'Del'], event)) {
      editorActions.trigger('removeSelection');
      return true;
    }
  });
};

var KeyboardModule$1 = {
  __init__: ['keyboard', 'keyboardBindings'],
  keyboard: ['type', Keyboard],
  keyboardBindings: ['type', KeyboardBindings]
};

const LOW_PRIORITY = 500;
class FormEditorKeyboardBindings {
  constructor(eventBus, keyboard) {
    eventBus.on('editorActions.init', LOW_PRIORITY, event => {
      const {
        editorActions
      } = event;
      this.registerBindings(keyboard, editorActions);
    });
  }

  registerBindings(keyboard, editorActions) {
    function addListener(action, fn) {
      if (editorActions.isRegistered(action)) {
        keyboard.addListener(fn);
      }
    } // undo
    // (CTRL|CMD) + Z


    addListener('undo', context => {
      const {
        keyEvent
      } = context;

      if (isCmd(keyEvent) && !isShift(keyEvent) && isKey(KEYS_UNDO, keyEvent)) {
        editorActions.trigger('undo');
        return true;
      }
    }); // redo
    // CTRL + Y
    // CMD + SHIFT + Z

    addListener('redo', context => {
      const {
        keyEvent
      } = context;

      if (isCmd(keyEvent) && (isKey(KEYS_REDO, keyEvent) || isKey(KEYS_UNDO, keyEvent) && isShift(keyEvent))) {
        editorActions.trigger('redo');
        return true;
      }
    });
  }

}
FormEditorKeyboardBindings.$inject = ['eventBus', 'keyboard'];

var KeyboardModule = {
  __depends__: [KeyboardModule$1],
  __init__: ['keyboardBindings'],
  keyboardBindings: ['type', FormEditorKeyboardBindings]
};

function arrayAdd$1(array, index, item) {
  array.splice(index, 0, item);
  return array;
}
function arrayRemove(array, index) {
  array.splice(index, 1);
  return array;
}
function updatePath(formFieldRegistry, formField, index) {
  const parent = formFieldRegistry.get(formField._parent);
  formField._path = [...parent._path, 'components', index];
  return formField;
}

class AddFormFieldHandler {
  /**
   * @constructor
   * @param { import('../../../FormEditor').default } formEditor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formEditor, formFieldRegistry) {
    this._formEditor = formEditor;
    this._formFieldRegistry = formFieldRegistry;
  }

  execute(context) {
    const {
      formField,
      targetFormField,
      targetIndex
    } = context;

    const {
      schema
    } = this._formEditor._getState();

    const targetPath = [...targetFormField._path, 'components'];
    formField._parent = targetFormField.id; // (1) Add new form field

    arrayAdd$1(get(schema, targetPath), targetIndex, formField); // (2) Update paths of new form field and its siblings

    get(schema, targetPath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index)); // (3) Add new form field to form field registry

    this._formFieldRegistry.add(formField); // TODO: Create updater/change support that automatically updates paths and schema on command execution


    this._formEditor._setState({
      schema
    });
  }

  revert(context) {
    const {
      formField,
      targetFormField,
      targetIndex
    } = context;

    const {
      schema
    } = this._formEditor._getState();

    const targetPath = [...targetFormField._path, 'components']; // (1) Remove new form field

    arrayRemove(get(schema, targetPath), targetIndex); // (2) Update paths of new form field and its siblings

    get(schema, targetPath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index)); // (3) Remove new form field from form field registry

    this._formFieldRegistry.remove(formField); // TODO: Create updater/change support that automatically updates paths and schema on command execution


    this._formEditor._setState({
      schema
    });
  }

}
AddFormFieldHandler.$inject = ['formEditor', 'formFieldRegistry'];

class EditFormFieldHandler {
  /**
   * @constructor
   * @param { import('../../../FormEditor').default } formEditor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formEditor, formFieldRegistry) {
    this._formEditor = formEditor;
    this._formFieldRegistry = formFieldRegistry;
  }

  execute(context) {
    const {
      formField,
      properties
    } = context;

    let {
      schema
    } = this._formEditor._getState();

    const oldProperties = {};

    for (let key in properties) {
      oldProperties[key] = formField[key];
      const property = properties[key];

      if (key === 'id') {
        if (property !== formField.id) {
          this._formFieldRegistry.updateId(formField, property);
        }
      } else {
        formField[key] = property;
      }
    }

    context.oldProperties = oldProperties; // TODO: Create updater/change support that automatically updates paths and schema on command execution

    this._formEditor._setState({
      schema
    });

    return formField;
  }

  revert(context) {
    const {
      formField,
      oldProperties
    } = context;

    let {
      schema
    } = this._formEditor._getState();

    for (let key in oldProperties) {
      const property = oldProperties[key];

      if (key === 'id') {
        if (property !== formField.id) {
          this._formFieldRegistry.updateId(formField, property);
        }
      } else {
        formField[key] = property;
      }
    } // TODO: Create updater/change support that automatically updates paths and schema on command execution


    this._formEditor._setState({
      schema
    });

    return formField;
  }

}
EditFormFieldHandler.$inject = ['formEditor', 'formFieldRegistry'];

class MoveFormFieldHandler {
  /**
   * @constructor
   * @param { import('../../../FormEditor').default } formEditor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formEditor, formFieldRegistry) {
    this._formEditor = formEditor;
    this._formFieldRegistry = formFieldRegistry;
  }

  execute(context) {
    this.moveFormField(context);
  }

  revert(context) {
    let {
      sourceFormField,
      targetFormField,
      sourceIndex,
      targetIndex
    } = context;
    this.moveFormField({
      sourceFormField: targetFormField,
      targetFormField: sourceFormField,
      sourceIndex: targetIndex,
      targetIndex: sourceIndex
    }, true);
  }

  moveFormField(context, revert) {
    let {
      sourceFormField,
      targetFormField,
      sourceIndex,
      targetIndex
    } = context;

    let {
      schema
    } = this._formEditor._getState();

    const sourcePath = [...sourceFormField._path, 'components'];

    if (sourceFormField.id === targetFormField.id) {
      if (revert) {
        if (sourceIndex > targetIndex) {
          sourceIndex--;
        }
      } else {
        if (sourceIndex < targetIndex) {
          targetIndex--;
        }
      } // (1) Move form field


      mutate(get(schema, sourcePath), sourceIndex, targetIndex); // (2) Update paths of new form field and its siblings

      get(schema, sourcePath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index));
    } else {
      const formField = get(schema, [...sourcePath, sourceIndex]);
      formField._parent = targetFormField.id; // (1) Remove form field

      arrayRemove(get(schema, sourcePath), sourceIndex); // (2) Update paths of siblings

      get(schema, sourcePath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index));
      const targetPath = [...targetFormField._path, 'components']; // (3) Add form field

      arrayAdd$1(get(schema, targetPath), targetIndex, formField); // (4) Update paths of siblings

      get(schema, targetPath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index));
    } // TODO: Create updater/change support that automatically updates paths and schema on command execution


    this._formEditor._setState({
      schema
    });
  }

}
MoveFormFieldHandler.$inject = ['formEditor', 'formFieldRegistry'];

class RemoveFormFieldHandler {
  /**
   * @constructor
   * @param { import('../../../FormEditor').default } formEditor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formEditor, formFieldRegistry) {
    this._formEditor = formEditor;
    this._formFieldRegistry = formFieldRegistry;
  }

  execute(context) {
    const {
      sourceFormField,
      sourceIndex
    } = context;

    let {
      schema
    } = this._formEditor._getState();

    const sourcePath = [...sourceFormField._path, 'components'];
    const formField = context.formField = get(schema, [...sourcePath, sourceIndex]); // (1) Remove form field

    arrayRemove(get(schema, sourcePath), sourceIndex); // (2) Update paths of its siblings

    get(schema, sourcePath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index)); // (3) Remove form field from form field registry

    this._formFieldRegistry.remove(formField); // TODO: Create updater/change support that automatically updates paths and schema on command execution


    this._formEditor._setState({
      schema
    });
  }

  revert(context) {
    const {
      formField,
      sourceFormField,
      sourceIndex
    } = context;

    let {
      schema
    } = this._formEditor._getState();

    const sourcePath = [...sourceFormField._path, 'components']; // (1) Add form field

    arrayAdd$1(get(schema, sourcePath), sourceIndex, formField); // (2) Update paths of its siblings

    get(schema, sourcePath).forEach((formField, index) => updatePath(this._formFieldRegistry, formField, index)); // (3) Add form field to form field registry

    this._formFieldRegistry.add(formField); // TODO: Create updater/change support that automatically updates paths and schema on command execution


    this._formEditor._setState({
      schema
    });
  }

}
RemoveFormFieldHandler.$inject = ['formEditor', 'formFieldRegistry'];

class UpdateIdClaimHandler {
  /**
   * @constructor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formFieldRegistry) {
    this._formFieldRegistry = formFieldRegistry;
  }

  execute(context) {
    const {
      claiming,
      formField,
      id
    } = context;

    if (claiming) {
      this._formFieldRegistry._ids.claim(id, formField);
    } else {
      this._formFieldRegistry._ids.unclaim(id);
    }
  }

  revert(context) {
    const {
      claiming,
      formField,
      id
    } = context;

    if (claiming) {
      this._formFieldRegistry._ids.unclaim(id);
    } else {
      this._formFieldRegistry._ids.claim(id, formField);
    }
  }

}
UpdateIdClaimHandler.$inject = ['formFieldRegistry'];

class UpdateKeyClaimHandler {
  /**
   * @constructor
   * @param { import('../../../core/FormFieldRegistry').default } formFieldRegistry
   */
  constructor(formFieldRegistry) {
    this._formFieldRegistry = formFieldRegistry;
  }

  execute(context) {
    const {
      claiming,
      formField,
      key
    } = context;

    if (claiming) {
      this._formFieldRegistry._keys.claim(key, formField);
    } else {
      this._formFieldRegistry._keys.unclaim(key);
    }
  }

  revert(context) {
    const {
      claiming,
      formField,
      key
    } = context;

    if (claiming) {
      this._formFieldRegistry._keys.unclaim(key);
    } else {
      this._formFieldRegistry._keys.claim(key, formField);
    }
  }

}
UpdateKeyClaimHandler.$inject = ['formFieldRegistry'];

class Modeling {
  constructor(commandStack, eventBus, formEditor, formFieldRegistry, fieldFactory) {
    this._commandStack = commandStack;
    this._formEditor = formEditor;
    this._formFieldRegistry = formFieldRegistry;
    this._fieldFactory = fieldFactory;
    eventBus.on('form.init', () => {
      this.registerHandlers();
    });
  }

  registerHandlers() {
    Object.entries(this.getHandlers()).forEach(([id, handler]) => {
      this._commandStack.registerHandler(id, handler);
    });
  }

  getHandlers() {
    return {
      'formField.add': AddFormFieldHandler,
      'formField.edit': EditFormFieldHandler,
      'formField.move': MoveFormFieldHandler,
      'formField.remove': RemoveFormFieldHandler,
      'id.updateClaim': UpdateIdClaimHandler,
      'key.updateClaim': UpdateKeyClaimHandler
    };
  }

  addFormField(attrs, targetFormField, targetIndex) {
    const formField = this._fieldFactory.create(attrs);

    const context = {
      formField,
      targetFormField,
      targetIndex
    };

    this._commandStack.execute('formField.add', context);

    return formField;
  }

  editFormField(formField, properties, value) {
    if (!isObject(properties)) {
      properties = {
        [properties]: value
      };
    }

    const context = {
      formField,
      properties
    };

    this._commandStack.execute('formField.edit', context);
  }

  moveFormField(formField, sourceFormField, targetFormField, sourceIndex, targetIndex) {
    const context = {
      formField,
      sourceFormField,
      targetFormField,
      sourceIndex,
      targetIndex
    };

    this._commandStack.execute('formField.move', context);
  }

  removeFormField(formField, sourceFormField, sourceIndex) {
    const context = {
      formField,
      sourceFormField,
      sourceIndex
    };

    this._commandStack.execute('formField.remove', context);
  }

  claimId(formField, id) {
    const context = {
      formField,
      id,
      claiming: true
    };

    this._commandStack.execute('id.updateClaim', context);
  }

  unclaimId(formField, id) {
    const context = {
      formField,
      id,
      claiming: false
    };

    this._commandStack.execute('id.updateClaim', context);
  }

  claimKey(formField, key) {
    const context = {
      formField,
      key,
      claiming: true
    };

    this._commandStack.execute('key.updateClaim', context);
  }

  unclaimKey(formField, key) {
    const context = {
      formField,
      key,
      claiming: false
    };

    this._commandStack.execute('key.updateClaim', context);
  }

}
Modeling.$inject = ['commandStack', 'eventBus', 'formEditor', 'formFieldRegistry', 'fieldFactory'];

var DEFAULT_PRIORITY$1 = 1000;
/**
 * A utility that can be used to plug-in into the command execution for
 * extension and/or validation.
 *
 * @param {EventBus} eventBus
 *
 * @example
 *
 * import inherits from 'inherits';
 *
 * import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';
 *
 * function CommandLogger(eventBus) {
 *   CommandInterceptor.call(this, eventBus);
 *
 *   this.preExecute(function(event) {
 *     console.log('command pre-execute', event);
 *   });
 * }
 *
 * inherits(CommandLogger, CommandInterceptor);
 *
 */

function CommandInterceptor(eventBus) {
  this._eventBus = eventBus;
}
CommandInterceptor.$inject = ['eventBus'];

function unwrapEvent(fn, that) {
  return function (event) {
    return fn.call(that || null, event.context, event.command, event);
  };
}
/**
 * Register an interceptor for a command execution
 *
 * @param {string|Array<string>} [events] list of commands to register on
 * @param {string} [hook] command hook, i.e. preExecute, executed to listen on
 * @param {number} [priority] the priority on which to hook into the execution
 * @param {Function} handlerFn interceptor to be invoked with (event)
 * @param {boolean} unwrap if true, unwrap the event and pass (context, command, event) to the
 *                          listener instead
 * @param {Object} [that] Pass context (`this`) to the handler function
 */


CommandInterceptor.prototype.on = function (events, hook, priority, handlerFn, unwrap, that) {
  if (isFunction(hook) || isNumber(hook)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = hook;
    hook = null;
  }

  if (isFunction(priority)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = DEFAULT_PRIORITY$1;
  }

  if (isObject(unwrap)) {
    that = unwrap;
    unwrap = false;
  }

  if (!isFunction(handlerFn)) {
    throw new Error('handlerFn must be a function');
  }

  if (!isArray(events)) {
    events = [events];
  }

  var eventBus = this._eventBus;
  forEach(events, function (event) {
    // concat commandStack(.event)?(.hook)?
    var fullEvent = ['commandStack', event, hook].filter(function (e) {
      return e;
    }).join('.');
    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
  });
};

var hooks = ['canExecute', 'preExecute', 'preExecuted', 'execute', 'executed', 'postExecute', 'postExecuted', 'revert', 'reverted'];
/*
 * Install hook shortcuts
 *
 * This will generate the CommandInterceptor#(preExecute|...|reverted) methods
 * which will in term forward to CommandInterceptor#on.
 */

forEach(hooks, function (hook) {
  /**
   * {canExecute|preExecute|preExecuted|execute|executed|postExecute|postExecuted|revert|reverted}
   *
   * A named hook for plugging into the command execution
   *
   * @param {string|Array<string>} [events] list of commands to register on
   * @param {number} [priority] the priority on which to hook into the execution
   * @param {Function} handlerFn interceptor to be invoked with (event)
   * @param {boolean} [unwrap=false] if true, unwrap the event and pass (context, command, event) to the
   *                          listener instead
   * @param {Object} [that] Pass context (`this`) to the handler function
   */
  CommandInterceptor.prototype[hook] = function (events, priority, handlerFn, unwrap, that) {
    if (isFunction(events) || isNumber(events)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = events;
      events = null;
    }

    this.on(events, hook, priority, handlerFn, unwrap, that);
  };
});

class IdBehavior extends CommandInterceptor {
  constructor(eventBus, modeling) {
    super(eventBus); // @ts-ignore-next-line

    this.preExecute('formField.remove', function (context) {
      const {
        formField
      } = context;
      const {
        id
      } = formField;
      modeling.unclaimId(formField, id);
    }, true); // @ts-ignore-next-line

    this.preExecute('formField.edit', function (context) {
      const {
        formField,
        properties
      } = context;

      if ('id' in properties) {
        modeling.unclaimId(formField, formField.id);
        modeling.claimId(formField, properties.id);
      }
    }, true);
  }

}
IdBehavior.$inject = ['eventBus', 'modeling'];

class KeyBehavior extends CommandInterceptor {
  constructor(eventBus, modeling) {
    super(eventBus); // @ts-ignore-next-line

    this.preExecute('formField.remove', function (context) {
      const {
        formField
      } = context;
      const {
        key
      } = formField;

      if (key) {
        modeling.unclaimKey(formField, key);
      }
    }, true); // @ts-ignore-next-line

    this.preExecute('formField.edit', function (context) {
      const {
        formField,
        properties
      } = context;

      if ('key' in properties) {
        modeling.unclaimKey(formField, formField.key);
        modeling.claimKey(formField, properties.key);
      }
    }, true);
  }

}
KeyBehavior.$inject = ['eventBus', 'modeling'];

var behaviorModule = {
  __init__: ['idBehavior', 'keyBehavior'],
  idBehavior: ['type', IdBehavior],
  keyBehavior: ['type', KeyBehavior]
};

/**
 * A service that offers un- and redoable execution of commands.
 *
 * The command stack is responsible for executing modeling actions
 * in a un- and redoable manner. To do this it delegates the actual
 * command execution to {@link CommandHandler}s.
 *
 * Command handlers provide {@link CommandHandler#execute(ctx)} and
 * {@link CommandHandler#revert(ctx)} methods to un- and redo a command
 * identified by a command context.
 *
 *
 * ## Life-Cycle events
 *
 * In the process the command stack fires a number of life-cycle events
 * that other components to participate in the command execution.
 *
 *    * preExecute
 *    * preExecuted
 *    * execute
 *    * executed
 *    * postExecute
 *    * postExecuted
 *    * revert
 *    * reverted
 *
 * A special event is used for validating, whether a command can be
 * performed prior to its execution.
 *
 *    * canExecute
 *
 * Each of the events is fired as `commandStack.{eventName}` and
 * `commandStack.{commandName}.{eventName}`, respectively. This gives
 * components fine grained control on where to hook into.
 *
 * The event object fired transports `command`, the name of the
 * command and `context`, the command context.
 *
 *
 * ## Creating Command Handlers
 *
 * Command handlers should provide the {@link CommandHandler#execute(ctx)}
 * and {@link CommandHandler#revert(ctx)} methods to implement
 * redoing and undoing of a command.
 *
 * A command handler _must_ ensure undo is performed properly in order
 * not to break the undo chain. It must also return the shapes that
 * got changed during the `execute` and `revert` operations.
 *
 * Command handlers may execute other modeling operations (and thus
 * commands) in their `preExecute` and `postExecute` phases. The command
 * stack will properly group all commands together into a logical unit
 * that may be re- and undone atomically.
 *
 * Command handlers must not execute other commands from within their
 * core implementation (`execute`, `revert`).
 *
 *
 * ## Change Tracking
 *
 * During the execution of the CommandStack it will keep track of all
 * elements that have been touched during the command's execution.
 *
 * At the end of the CommandStack execution it will notify interested
 * components via an 'elements.changed' event with all the dirty
 * elements.
 *
 * The event can be picked up by components that are interested in the fact
 * that elements have been changed. One use case for this is updating
 * their graphical representation after moving / resizing or deletion.
 *
 * @see CommandHandler
 *
 * @param {EventBus} eventBus
 * @param {Injector} injector
 */

function CommandStack(eventBus, injector) {
  /**
   * A map of all registered command handlers.
   *
   * @type {Object}
   */
  this._handlerMap = {};
  /**
   * A stack containing all re/undoable actions on the diagram
   *
   * @type {Array<Object>}
   */

  this._stack = [];
  /**
   * The current index on the stack
   *
   * @type {number}
   */

  this._stackIdx = -1;
  /**
   * Current active commandStack execution
   *
   * @type {Object}
   * @property {Object[]} actions
   * @property {Object[]} dirty
   * @property { 'undo' | 'redo' | 'clear' | 'execute' | null } trigger the cause of the current excecution
   */

  this._currentExecution = {
    actions: [],
    dirty: [],
    trigger: null
  };
  this._injector = injector;
  this._eventBus = eventBus;
  this._uid = 1;
  eventBus.on(['diagram.destroy', 'diagram.clear'], function () {
    this.clear(false);
  }, this);
}
CommandStack.$inject = ['eventBus', 'injector'];
/**
 * Execute a command
 *
 * @param {string} command the command to execute
 * @param {Object} context the environment to execute the command in
 */

CommandStack.prototype.execute = function (command, context) {
  if (!command) {
    throw new Error('command required');
  }

  this._currentExecution.trigger = 'execute';
  var action = {
    command: command,
    context: context
  };

  this._pushAction(action);

  this._internalExecute(action);

  this._popAction(action);
};
/**
 * Ask whether a given command can be executed.
 *
 * Implementors may hook into the mechanism on two ways:
 *
 *   * in event listeners:
 *
 *     Users may prevent the execution via an event listener.
 *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.
 *
 *   * in command handlers:
 *
 *     If the method {@link CommandHandler#canExecute} is implemented in a handler
 *     it will be called to figure out whether the execution is allowed.
 *
 * @param  {string} command the command to execute
 * @param  {Object} context the environment to execute the command in
 *
 * @return {boolean} true if the command can be executed
 */


CommandStack.prototype.canExecute = function (command, context) {
  var action = {
    command: command,
    context: context
  };

  var handler = this._getHandler(command);

  var result = this._fire(command, 'canExecute', action); // handler#canExecute will only be called if no listener
  // decided on a result already


  if (result === undefined) {
    if (!handler) {
      return false;
    }

    if (handler.canExecute) {
      result = handler.canExecute(context);
    }
  }

  return result;
};
/**
 * Clear the command stack, erasing all undo / redo history
 */


CommandStack.prototype.clear = function (emit) {
  this._stack.length = 0;
  this._stackIdx = -1;

  if (emit !== false) {
    this._fire('changed', {
      trigger: 'clear'
    });
  }
};
/**
 * Undo last command(s)
 */


CommandStack.prototype.undo = function () {
  var action = this._getUndoAction(),
      next;

  if (action) {
    this._currentExecution.trigger = 'undo';

    this._pushAction(action);

    while (action) {
      this._internalUndo(action);

      next = this._getUndoAction();

      if (!next || next.id !== action.id) {
        break;
      }

      action = next;
    }

    this._popAction();
  }
};
/**
 * Redo last command(s)
 */


CommandStack.prototype.redo = function () {
  var action = this._getRedoAction(),
      next;

  if (action) {
    this._currentExecution.trigger = 'redo';

    this._pushAction(action);

    while (action) {
      this._internalExecute(action, true);

      next = this._getRedoAction();

      if (!next || next.id !== action.id) {
        break;
      }

      action = next;
    }

    this._popAction();
  }
};
/**
 * Register a handler instance with the command stack
 *
 * @param {string} command
 * @param {CommandHandler} handler
 */


CommandStack.prototype.register = function (command, handler) {
  this._setHandler(command, handler);
};
/**
 * Register a handler type with the command stack
 * by instantiating it and injecting its dependencies.
 *
 * @param {string} command
 * @param {Function} a constructor for a {@link CommandHandler}
 */


CommandStack.prototype.registerHandler = function (command, handlerCls) {
  if (!command || !handlerCls) {
    throw new Error('command and handlerCls must be defined');
  }

  var handler = this._injector.instantiate(handlerCls);

  this.register(command, handler);
};

CommandStack.prototype.canUndo = function () {
  return !!this._getUndoAction();
};

CommandStack.prototype.canRedo = function () {
  return !!this._getRedoAction();
}; // stack access  //////////////////////


CommandStack.prototype._getRedoAction = function () {
  return this._stack[this._stackIdx + 1];
};

CommandStack.prototype._getUndoAction = function () {
  return this._stack[this._stackIdx];
}; // internal functionality //////////////////////


CommandStack.prototype._internalUndo = function (action) {
  var self = this;
  var command = action.command,
      context = action.context;

  var handler = this._getHandler(command); // guard against illegal nested command stack invocations


  this._atomicDo(function () {
    self._fire(command, 'revert', action);

    if (handler.revert) {
      self._markDirty(handler.revert(context));
    }

    self._revertedAction(action);

    self._fire(command, 'reverted', action);
  });
};

CommandStack.prototype._fire = function (command, qualifier, event) {
  if (arguments.length < 3) {
    event = qualifier;
    qualifier = null;
  }

  var names = qualifier ? [command + '.' + qualifier, qualifier] : [command],
      i,
      name,
      result;
  event = this._eventBus.createEvent(event);

  for (i = 0; name = names[i]; i++) {
    result = this._eventBus.fire('commandStack.' + name, event);

    if (event.cancelBubble) {
      break;
    }
  }

  return result;
};

CommandStack.prototype._createId = function () {
  return this._uid++;
};

CommandStack.prototype._atomicDo = function (fn) {
  var execution = this._currentExecution;
  execution.atomic = true;

  try {
    fn();
  } finally {
    execution.atomic = false;
  }
};

CommandStack.prototype._internalExecute = function (action, redo) {
  var self = this;
  var command = action.command,
      context = action.context;

  var handler = this._getHandler(command);

  if (!handler) {
    throw new Error('no command handler registered for <' + command + '>');
  }

  this._pushAction(action);

  if (!redo) {
    this._fire(command, 'preExecute', action);

    if (handler.preExecute) {
      handler.preExecute(context);
    }

    this._fire(command, 'preExecuted', action);
  } // guard against illegal nested command stack invocations


  this._atomicDo(function () {
    self._fire(command, 'execute', action);

    if (handler.execute) {
      // actual execute + mark return results as dirty
      self._markDirty(handler.execute(context));
    } // log to stack


    self._executedAction(action, redo);

    self._fire(command, 'executed', action);
  });

  if (!redo) {
    this._fire(command, 'postExecute', action);

    if (handler.postExecute) {
      handler.postExecute(context);
    }

    this._fire(command, 'postExecuted', action);
  }

  this._popAction(action);
};

CommandStack.prototype._pushAction = function (action) {
  var execution = this._currentExecution,
      actions = execution.actions;
  var baseAction = actions[0];

  if (execution.atomic) {
    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');
  }

  if (!action.id) {
    action.id = baseAction && baseAction.id || this._createId();
  }

  actions.push(action);
};

CommandStack.prototype._popAction = function () {
  var execution = this._currentExecution,
      trigger = execution.trigger,
      actions = execution.actions,
      dirty = execution.dirty;
  actions.pop();

  if (!actions.length) {
    this._eventBus.fire('elements.changed', {
      elements: uniqueBy('id', dirty.reverse())
    });

    dirty.length = 0;

    this._fire('changed', {
      trigger: trigger
    });

    execution.trigger = null;
  }
};

CommandStack.prototype._markDirty = function (elements) {
  var execution = this._currentExecution;

  if (!elements) {
    return;
  }

  elements = isArray(elements) ? elements : [elements];
  execution.dirty = execution.dirty.concat(elements);
};

CommandStack.prototype._executedAction = function (action, redo) {
  var stackIdx = ++this._stackIdx;

  if (!redo) {
    this._stack.splice(stackIdx, this._stack.length, action);
  }
};

CommandStack.prototype._revertedAction = function (action) {
  this._stackIdx--;
};

CommandStack.prototype._getHandler = function (command) {
  return this._handlerMap[command];
};

CommandStack.prototype._setHandler = function (command, handler) {
  if (!command || !handler) {
    throw new Error('command and handler required');
  }

  if (this._handlerMap[command]) {
    throw new Error('overriding handler for command <' + command + '>');
  }

  this._handlerMap[command] = handler;
};

var commandModule = {
  commandStack: ['type', CommandStack]
};

var ModelingModule = {
  __depends__: [behaviorModule, commandModule],
  __init__: ['modeling'],
  modeling: ['type', Modeling]
};

class Selection {
  constructor(eventBus) {
    this._eventBus = eventBus;
    this._selection = null;
  }

  get() {
    return this._selection;
  }

  set(selection) {
    if (this._selection === selection) {
      return;
    }

    this._selection = selection;

    this._eventBus.fire('selection.changed', {
      selection: this._selection
    });
  }

  toggle(selection) {
    const newSelection = this._selection === selection ? null : selection;
    this.set(newSelection);
  }

  clear() {
    this.set(null);
  }

  isSelected(formField) {
    return this._selection === formField;
  }

}
Selection.$inject = ['eventBus'];

class SelectionBehavior {
  constructor(eventBus, selection) {
    eventBus.on(['commandStack.formField.add.postExecuted', 'commandStack.formField.move.postExecuted'], ({
      context
    }) => {
      const {
        formField
      } = context;
      selection.set(formField);
    });
    eventBus.on('commandStack.formField.remove.postExecuted', ({
      context
    }) => {
      const {
        sourceFormField,
        sourceIndex
      } = context;
      const formField = sourceFormField.components[sourceIndex] || sourceFormField.components[sourceIndex - 1];

      if (formField) {
        selection.set(formField);
      } else {
        selection.clear();
      }
    });
    eventBus.on('formField.remove', ({
      formField
    }) => {
      if (selection.isSelected(formField)) {
        selection.clear();
      }
    });
  }

}
SelectionBehavior.$inject = ['eventBus', 'selection'];

var SelectionModule = {
  __init__: ['selection', 'selectionBehavior'],
  selection: ['type', Selection],
  selectionBehavior: ['type', SelectionBehavior]
};

const types = [{
  label: 'Text Field',
  type: 'textfield'
}, {
  label: 'Number',
  type: 'number'
}, {
  label: 'Checkbox',
  type: 'checkbox'
}, {
  label: 'Checklist',
  type: 'checklist'
}, {
  label: 'Taglist',
  type: 'taglist'
}, {
  label: 'Radio',
  type: 'radio'
}, {
  label: 'Select',
  type: 'select'
}, {
  label: 'Text',
  type: 'text'
}, {
  label: 'Button',
  type: 'button'
}];
function Palette(props) {
  return jsxs("div", {
    class: "fjs-palette",
    children: [jsxs("div", {
      class: "fjs-palette-header",
      title: "Form elements library",
      children: [jsx("span", {
        class: "fjs-hide-compact",
        children: "FORM ELEMENTS "
      }), "LIBRARY"]
    }), jsx("div", {
      class: "fjs-palette-fields fjs-drag-container fjs-no-drop",
      children: types.map(({
        label,
        type
      }) => {
        const Icon = iconsByType[type];
        return jsxs("div", {
          class: "fjs-palette-field fjs-drag-copy fjs-no-drop",
          "data-field-type": type,
          title: `Create a ${label} element`,
          children: [Icon ? jsx(Icon, {
            class: "fjs-palette-field-icon",
            width: "36",
            height: "36",
            viewBox: "0 0 54 54"
          }) : null, jsx("span", {
            class: "fjs-palette-field-text",
            children: label
          })]
        });
      })
    })]
  });
}

class PaletteRenderer {
  constructor(paletteConfig, eventBus) {
    const {
      parent
    } = paletteConfig || {};
    this._eventBus = eventBus;
    this._container = domify('<div class="fjs-palette-container"></div>');

    if (parent) {
      this.attachTo(parent);
    }

    this._eventBus.once('formEditor.rendered', 500, () => {
      this._render();
    });
  }
  /**
   * Attach the palette to a parent node.
   *
   * @param {HTMLElement} container
   */


  attachTo(container) {
    if (!container) {
      throw new Error('container required');
    }

    if (typeof container === 'string') {
      container = query(container);
    } // (1) detach from old parent


    this.detach(); // (2) append to parent container

    container.appendChild(this._container); // (3) notify interested parties

    this._eventBus.fire('palette.attach');
  }
  /**
   * Detach the palette from its parent node.
   */


  detach() {
    const parentNode = this._container.parentNode;

    if (parentNode) {
      parentNode.removeChild(this._container);

      this._eventBus.fire('palette.detach');
    }
  }

  _render() {
    render(jsx(Palette, {}), this._container);

    this._eventBus.fire('palette.rendered');
  }

  _destroy() {
    if (this._container) {
      render(null, this._container);

      this._eventBus.fire('palette.destroyed');
    }
  }

}
PaletteRenderer.$inject = ['config.palette', 'eventBus'];

var PaletteModule = {
  palette: ['type', PaletteRenderer]
};

var ArrowIcon = function ArrowIcon(props) {
  return jsx("svg", { ...props,
    children: jsx("path", {
      fillRule: "evenodd",
      d: "m11.657 8-4.95 4.95a1 1 0 0 1-1.414-1.414L8.828 8 5.293 4.464A1 1 0 1 1 6.707 3.05L11.657 8z"
    })
  });
};

ArrowIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};

var CreateIcon = function CreateIcon(props) {
  return jsx("svg", { ...props,
    children: jsx("path", {
      fillRule: "evenodd",
      d: "M9 13V9h4a1 1 0 0 0 0-2H9V3a1 1 0 1 0-2 0v4H3a1 1 0 1 0 0 2h4v4a1 1 0 0 0 2 0z"
    })
  });
};

CreateIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};

var DeleteIcon = function DeleteIcon(props) {
  return jsx("svg", { ...props,
    children: jsx("path", {
      fillRule: "evenodd",
      d: "M12 6v7c0 1.1-.4 1.55-1.5 1.55h-5C4.4 14.55 4 14.1 4 13V6h8zm-1.5 1.5h-5v4.3c0 .66.5 1.2 1.111 1.2H9.39c.611 0 1.111-.54 1.111-1.2V7.5zM13 3h-2l-1-1H6L5 3H3v1.5h10V3z"
    })
  });
};

DeleteIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};

var ExternalLinkIcon = function ExternalLinkIcon(props) {
  return jsx("svg", { ...props,
    children: jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12.637 12.637v-4.72h1.362v4.721c0 .36-.137.676-.411.95-.275.275-.591.412-.95.412H3.362c-.38 0-.703-.132-.967-.396A1.315 1.315 0 0 1 2 12.638V3.362c0-.38.132-.703.396-.967S2.982 2 3.363 2h4.553v1.363H3.363v9.274h9.274zM14 2H9.28l-.001 1.362h2.408L5.065 9.984l.95.95 6.622-6.622v2.409H14V2z",
      fill: "#818798"
    })
  });
};

ExternalLinkIcon.defaultProps = {
  width: "16",
  height: "16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};

var FeelRequiredIcon = function FeelRequiredIcon(props) {
  return jsxs("svg", { ...props,
    children: [jsx("path", {
      d: "M5.8 7.06V5.95h4.307v1.11H5.8zm0 3.071v-1.11h4.307v1.11H5.8z",
      fill: "#505562"
    }), jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M8 3.268A4.732 4.732 0 1 0 12.732 8H14a6 6 0 1 1-6-6v1.268z",
      fill: "#505562"
    }), jsx("path", {
      d: "m11.28 6.072-.832-.56 1.016-1.224L10 3.848l.312-.912 1.392.584L11.632 2h1.032l-.072 1.52 1.392-.584.312.912-1.464.44 1.008 1.224-.832.552-.864-1.296-.864 1.304z",
      fill: "#505562"
    })]
  });
};

FeelRequiredIcon.defaultProps = {
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};

var FeelOptionalIcon = function FeelOptionalIcon(props) {
  return jsxs("svg", { ...props,
    children: [jsx("path", {
      d: "M5.845 7.04V5.93h4.307v1.11H5.845zm0 3.07V9h4.307v1.11H5.845z",
      fill: "#505562"
    }), jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M3.286 8a4.714 4.714 0 1 0 9.428 0 4.714 4.714 0 0 0-9.428 0zM8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2z",
      fill: "#505562"
    })]
  });
};

FeelOptionalIcon.defaultProps = {
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};

function Header(props) {
  const {
    element,
    headerProvider
  } = props;
  const {
    getElementIcon,
    getDocumentationRef,
    getElementLabel,
    getTypeLabel
  } = headerProvider;
  const label = getElementLabel(element);
  const type = getTypeLabel(element);
  const documentationRef = getDocumentationRef && getDocumentationRef(element);
  const ElementIcon = getElementIcon(element);
  return jsxs("div", {
    class: "bio-properties-panel-header",
    children: [jsx("div", {
      class: "bio-properties-panel-header-icon",
      children: ElementIcon && jsx(ElementIcon, {
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      })
    }), jsxs("div", {
      class: "bio-properties-panel-header-labels",
      children: [jsx("div", {
        title: type,
        class: "bio-properties-panel-header-type",
        children: type
      }), label ? jsx("div", {
        title: label,
        class: "bio-properties-panel-header-label",
        children: label
      }) : null]
    }), jsx("div", {
      class: "bio-properties-panel-header-actions",
      children: documentationRef ? jsx("a", {
        rel: "noopener",
        class: "bio-properties-panel-header-link",
        href: documentationRef,
        title: "Open documentation",
        target: "_blank",
        children: jsx(ExternalLinkIcon, {})
      }) : null
    })]
  });
}

const DescriptionContext = createContext({
  description: {},
  getDescriptionForId: () => {}
});
/**
 * @typedef {Function} <propertiesPanel.showEntry> callback
 *
 * @example
 *
 * useEvent('propertiesPanel.showEntry', ({ focus = false, ...rest }) => {
 *   // ...
 * });
 *
 * @param {Object} context
 * @param {boolean} [context.focus]
 *
 * @returns void
 */

const EventContext = createContext({
  eventBus: null
});
const LayoutContext = createContext({
  layout: {},
  setLayout: () => {},
  getLayoutForKey: () => {},
  setLayoutForKey: () => {}
});
/**
 * Accesses the global DescriptionContext and returns a description for a given id and element.
 *
 * @example
 * ```jsx
 * function TextField(props) {
 *   const description = useDescriptionContext('input1', element);
 * }
 * ```
 *
 * @param {string} id
 * @param {object} element
 *
 * @returns {string}
 */

function useDescriptionContext(id, element) {
  const {
    getDescriptionForId
  } = useContext(DescriptionContext);
  return getDescriptionForId(id, element);
}

const DEFAULT_PRIORITY = 1000;
/**
 * Subscribe to an event.
 *
 * @param {string} event
 * @param {Function} callback
 * @param {number} [priority]
 *
 * @returns {import('preact').Ref}
 */

function useEvent(event, callback, priority = DEFAULT_PRIORITY) {
  const {
    eventBus
  } = useContext(EventContext);
  useEffect(() => {
    if (!eventBus) {
      return;
    }

    eventBus.on(event, priority, callback);
    return () => eventBus.off(event, callback);
  }, [callback, event, eventBus, priority]);
}

const HIGH_PRIORITY = 10000;
/**
 * Buffer events and re-fire during passive effect phase.
 *
 * @param {string[]} bufferedEvents
 * @param {Object} [eventBus]
 */

function useEventBuffer(bufferedEvents, eventBus) {
  const buffer = useRef([]),
        buffering = useRef(true);

  const createCallback = event => data => {
    if (buffering.current === true) {
      buffer.current.unshift([event, data]);
    }
  }; // (1) buffer events


  useEffect(() => {
    if (!eventBus) {
      return;
    }

    const listeners = bufferedEvents.map(event => {
      return [event, createCallback(event)];
    });
    listeners.forEach(([event, callback]) => {
      eventBus.on(event, HIGH_PRIORITY, callback);
    });
    return () => {
      listeners.forEach(([event, callback]) => {
        eventBus.off(event, callback);
      });
    };
  }, [bufferedEvents, eventBus]); // (2) re-fire events

  useEffect(() => {
    if (!eventBus) {
      return;
    }

    buffering.current = false;

    while (buffer.current.length) {
      const [event, data] = buffer.current.pop();
      eventBus.fire(event, data);
    }

    buffering.current = true;
  });
}
/**
 * Creates a state that persists in the global LayoutContext.
 *
 * @example
 * ```jsx
 * function Group(props) {
 *   const [ open, setOpen ] = useLayoutState([ 'groups', 'foo', 'open' ], false);
 * }
 * ```
 *
 * @param {(string|number)[]} path
 * @param {any} [defaultValue]
 *
 * @returns {[ any, Function ]}
 */


function useLayoutState(path, defaultValue) {
  const {
    getLayoutForKey,
    setLayoutForKey
  } = useContext(LayoutContext);
  const layoutForKey = getLayoutForKey(path, defaultValue);
  const [value, set] = useState(layoutForKey);

  const setState = newValue => {
    // (1) set component state
    set(newValue); // (2) set context

    setLayoutForKey(path, newValue);
  };

  return [value, setState];
}
/**
 * @pinussilvestrus: we need to introduce our own hook to persist the previous
 * state on updates.
 *
 * cf. https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state
 */


function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}
/**
 * Subscribe to `propertiesPanel.showEntry`.
 *
 * @param {Function} show
 *
 * @returns {import('preact').Ref}
 */


function useShowEntryEvent(show) {
  const {
    onShow
  } = useContext(LayoutContext);
  const ref = useRef();
  const [focus, setFocus] = useState(false);
  const onShowEntry = useCallback(event => {
    if (show(event)) {
      if (isFunction(onShow)) {
        onShow();
      }

      if (event.focus && !focus) {
        setFocus(true);
      }
    }
  }, [show]);
  useEffect(() => {
    if (focus && ref.current) {
      if (isFunction(ref.current.focus)) {
        ref.current.focus();
      }

      if (isFunction(ref.current.select)) {
        ref.current.select();
      }

      setFocus(false);
    }
  }, [focus]);
  useEvent('propertiesPanel.showEntry', onShowEntry);
  return ref;
}
/**
 * Subscribe to `propertiesPanel.showError`. On `propertiesPanel.showError` set
 * temporary error. Fire `propertiesPanel.showEntry` for temporary error to be
 * visible. Unset error on `propertiesPanel.updated`.
 *
 * @param {Function} show
 *
 * @returns {import('preact').Ref}
 */


function useShowErrorEvent(show) {
  const {
    eventBus
  } = useContext(EventContext);
  const [temporaryError, setTemporaryError] = useState(null);
  const onPropertiesPanelUpdated = useCallback(() => setTemporaryError(null), []);
  useEvent('propertiesPanel.updated', onPropertiesPanelUpdated);
  const onShowError = useCallback(event => {
    setTemporaryError(null);

    if (show(event)) {
      if (eventBus) {
        eventBus.fire('propertiesPanel.showEntry', event);
      }

      setTemporaryError(event.message);
    }
  }, [show]);
  useEvent('propertiesPanel.showError', onShowError);
  return temporaryError;
}
/**
 * @callback setSticky
 * @param {boolean} value
 */

/**
 * Use IntersectionObserver to identify when DOM element is in sticky mode.
 * If sticky is observered setSticky(true) will be called.
 * If sticky mode is left, setSticky(false) will be called.
 *
 *
 * @param {Object} ref
 * @param {string} scrollContainerSelector
 * @param {setSticky} setSticky
 */


function useStickyIntersectionObserver(ref, scrollContainerSelector, setSticky) {
  useEffect(() => {
    // return early if IntersectionObserver is not available
    if (!IntersectionObserver) {
      return;
    }

    let observer;

    if (ref.current) {
      const scrollContainer = query(scrollContainerSelector);
      observer = new IntersectionObserver(entries => {
        if (entries[0].intersectionRatio < 1) {
          setSticky(true);
        } else if (entries[0].intersectionRatio === 1) {
          setSticky(false);
        }
      }, {
        root: scrollContainer,
        rootMargin: '0px 0px 999999% 0px',
        // Use bottom margin to avoid stickyness when scrolling out to bottom
        threshold: [1]
      });
      observer.observe(ref.current);
    } // Unobserve if unmounted


    return () => {
      if (ref.current && observer) {
        observer.unobserve(ref.current);
      }
    };
  }, [ref]);
}

function Group(props) {
  const {
    element,
    entries = [],
    id,
    label,
    shouldOpen = false
  } = props;
  const groupRef = useRef(null);
  const [open, setOpen] = useLayoutState(['groups', id, 'open'], shouldOpen);
  const onShow = useCallback(() => setOpen(true), [setOpen]);

  const toggleOpen = () => setOpen(!open);

  const [edited, setEdited] = useState(false);
  const [sticky, setSticky] = useState(false); // set edited state depending on all entries

  useEffect(() => {
    const hasOneEditedEntry = entries.find(entry => {
      const {
        id,
        isEdited
      } = entry;
      const entryNode = query(`[data-entry-id="${id}"]`);

      if (!isFunction(isEdited) || !entryNode) {
        return false;
      }

      const inputNode = query('.bio-properties-panel-input', entryNode);
      return isEdited(inputNode);
    });
    setEdited(hasOneEditedEntry);
  }, [entries]); // set css class when group is sticky to top

  useStickyIntersectionObserver(groupRef, 'div.bio-properties-panel-scroll-container', setSticky);
  const propertiesPanelContext = { ...useContext(LayoutContext),
    onShow
  };
  return jsxs("div", {
    class: "bio-properties-panel-group",
    "data-group-id": 'group-' + id,
    ref: groupRef,
    children: [jsxs("div", {
      class: classnames('bio-properties-panel-group-header', edited ? '' : 'empty', open ? 'open' : '', sticky && open ? 'sticky' : ''),
      onClick: toggleOpen,
      children: [jsx("div", {
        title: label,
        class: "bio-properties-panel-group-header-title",
        children: label
      }), jsxs("div", {
        class: "bio-properties-panel-group-header-buttons",
        children: [edited && jsx(DataMarker, {}), jsx("button", {
          title: "Toggle section",
          class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
          children: jsx(ArrowIcon, {
            class: open ? 'bio-properties-panel-arrow-down' : 'bio-properties-panel-arrow-right'
          })
        })]
      })]
    }), jsx("div", {
      class: classnames('bio-properties-panel-group-entries', open ? 'open' : ''),
      children: jsx(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: entries.map(entry => {
          const {
            component: Component,
            id
          } = entry;
          return createElement(Component, { ...entry,
            element: element,
            key: id
          });
        })
      })
    })]
  });
}

function DataMarker() {
  return jsx("div", {
    title: "Section contains data",
    class: "bio-properties-panel-dot"
  });
}
/**
 * @typedef { {
 *  text: (element: object) => string,
 *  icon?: (element: Object) => import('preact').Component
 * } } PlaceholderDefinition
 *
 * @param { PlaceholderDefinition } props
 */


function Placeholder(props) {
  const {
    text,
    icon: Icon
  } = props;
  return jsx("div", {
    class: "bio-properties-panel open",
    children: jsxs("section", {
      class: "bio-properties-panel-placeholder",
      children: [Icon && jsx(Icon, {
        class: "bio-properties-panel-placeholder-icon"
      }), jsx("p", {
        class: "bio-properties-panel-placeholder-text",
        children: text
      })]
    })
  });
}

const DEFAULT_LAYOUT = {
  open: true
};
const DEFAULT_DESCRIPTION = {};
const bufferedEvents = ['propertiesPanel.showEntry', 'propertiesPanel.showError'];
/**
 * @typedef { {
 *    component: import('preact').Component,
 *    id: String,
 *    isEdited?: Function
 * } } EntryDefinition
 *
 * @typedef { {
 *    autoFocusEntry: String,
 *    autoOpen?: Boolean,
 *    entries: Array<EntryDefinition>,
 *    id: String,
 *    label: String,
 *    remove: (event: MouseEvent) => void
 * } } ListItemDefinition
 *
 * @typedef { {
 *    add: (event: MouseEvent) => void,
 *    component: import('preact').Component,
 *    element: Object,
 *    id: String,
 *    items: Array<ListItemDefinition>,
 *    label: String,
 *    shouldSort?: Boolean,
 *    shouldOpen?: Boolean
 * } } ListGroupDefinition
 *
 * @typedef { {
 *    component?: import('preact').Component,
 *    entries: Array<EntryDefinition>,
 *    id: String,
 *    label: String,
 *    shouldOpen?: Boolean
 * } } GroupDefinition
 *
 *  @typedef { {
 *    [id: String]: GetDescriptionFunction
 * } } DescriptionConfig
 *
 * @callback { {
 * @param {string} id
 * @param {Object} element
 * @returns {string}
 * } } GetDescriptionFunction
 *
 * @typedef { {
 *  getEmpty: (element: object) => import('./components/Placeholder').PlaceholderDefinition,
 *  getMultiple: (element: Object) => import('./components/Placeholder').PlaceholderDefinition
 * } } PlaceholderProvider
 *
 */

/**
 * A basic properties panel component. Describes *how* content will be rendered, accepts
 * data from implementor to describe *what* will be rendered.
 *
 * @param {Object} props
 * @param {Object|Array} props.element
 * @param {import('./components/Header').HeaderProvider} props.headerProvider
 * @param {PlaceholderProvider} [props.placeholderProvider]
 * @param {Array<GroupDefinition|ListGroupDefinition>} props.groups
 * @param {Object} [props.layoutConfig]
 * @param {Function} [props.layoutChanged]
 * @param {DescriptionConfig} [props.descriptionConfig]
 * @param {Function} [props.descriptionLoaded]
 * @param {Object} [props.eventBus]
 */

function PropertiesPanel(props) {
  const {
    element,
    headerProvider,
    placeholderProvider,
    groups,
    layoutConfig = {},
    layoutChanged,
    descriptionConfig = {},
    descriptionLoaded,
    eventBus
  } = props; // set-up layout context

  const [layout, setLayout] = useState(createLayout(layoutConfig));
  useEffect(() => {
    if (typeof layoutChanged === 'function') {
      layoutChanged(layout);
    }
  }, [layout, layoutChanged]);

  const getLayoutForKey = (key, defaultValue) => {
    return get(layout, key, defaultValue);
  };

  const setLayoutForKey = (key, config) => {
    const newLayout = assign({}, layout);
    set(newLayout, key, config);
    setLayout(newLayout);
  };

  const layoutContext = {
    layout,
    setLayout,
    getLayoutForKey,
    setLayoutForKey
  }; // set-up description context

  const description = createDescriptionContext(descriptionConfig);

  if (typeof descriptionLoaded === 'function') {
    descriptionLoaded(description);
  }

  const getDescriptionForId = (id, element) => {
    return description[id] && description[id](element);
  };

  const descriptionContext = {
    description,
    getDescriptionForId
  };
  useEventBuffer(bufferedEvents, eventBus);
  const eventContext = {
    eventBus
  };
  const propertiesPanelContext = {
    element
  }; // empty state

  if (placeholderProvider && !element) {
    return jsx(Placeholder, { ...placeholderProvider.getEmpty()
    });
  } // multiple state


  if (placeholderProvider && isArray(element)) {
    return jsx(Placeholder, { ...placeholderProvider.getMultiple()
    });
  }

  return jsx(LayoutContext.Provider, {
    value: propertiesPanelContext,
    children: jsx(DescriptionContext.Provider, {
      value: descriptionContext,
      children: jsx(LayoutContext.Provider, {
        value: layoutContext,
        children: jsx(EventContext.Provider, {
          value: eventContext,
          children: jsxs("div", {
            class: classnames('bio-properties-panel', layout.open ? 'open' : ''),
            children: [jsx(Header, {
              element: element,
              headerProvider: headerProvider
            }), jsx("div", {
              class: "bio-properties-panel-scroll-container",
              children: groups.map(group => {
                const {
                  component: Component = Group,
                  id
                } = group;
                return createElement(Component, { ...group,
                  key: id,
                  element: element
                });
              })
            })]
          })
        })
      })
    })
  });
} // helpers //////////////////


function createLayout(overrides) {
  return { ...DEFAULT_LAYOUT,
    ...overrides
  };
}

function createDescriptionContext(overrides) {
  return { ...DEFAULT_DESCRIPTION,
    ...overrides
  };
}

function CollapsibleEntry(props) {
  const {
    element,
    entries = [],
    id,
    label,
    open: shouldOpen,
    remove
  } = props;
  const [open, setOpen] = useState(shouldOpen);

  const toggleOpen = () => setOpen(!open);

  const {
    onShow
  } = useContext(LayoutContext);
  const propertiesPanelContext = { ...useContext(LayoutContext),
    onShow: useCallback(() => {
      setOpen(true);

      if (isFunction(onShow)) {
        onShow();
      }
    }, [onShow, setOpen])
  }; // todo(pinussilvestrus): translate once we have a translate mechanism for the core

  const placeholderLabel = '<empty>';
  return jsxs("div", {
    "data-entry-id": id,
    class: classnames('bio-properties-panel-collapsible-entry', open ? 'open' : ''),
    children: [jsxs("div", {
      class: "bio-properties-panel-collapsible-entry-header",
      onClick: toggleOpen,
      children: [jsx("div", {
        title: label || placeholderLabel,
        class: classnames('bio-properties-panel-collapsible-entry-header-title', !label && 'empty'),
        children: label || placeholderLabel
      }), jsx("button", {
        title: "Toggle list item",
        class: "bio-properties-panel-arrow  bio-properties-panel-collapsible-entry-arrow",
        children: jsx(ArrowIcon, {
          class: open ? 'bio-properties-panel-arrow-down' : 'bio-properties-panel-arrow-right'
        })
      }), remove ? jsx("button", {
        title: "Delete item",
        class: "bio-properties-panel-remove-entry",
        onClick: remove,
        children: jsx(DeleteIcon, {})
      }) : null]
    }), jsx("div", {
      class: classnames('bio-properties-panel-collapsible-entry-entries', open ? 'open' : ''),
      children: jsx(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: entries.map(entry => {
          const {
            component: Component,
            id
          } = entry;
          return createElement(Component, { ...entry,
            element: element,
            key: id
          });
        })
      })
    })]
  });
}

function ListItem(props) {
  const {
    autoFocusEntry,
    autoOpen
  } = props; // focus specified entry on auto open

  useEffect(() => {
    if (autoOpen && autoFocusEntry) {
      const entry = query(`[data-entry-id="${autoFocusEntry}"]`);
      const focusableInput = query('.bio-properties-panel-input', entry);

      if (focusableInput) {
        if (isFunction(focusableInput.select)) {
          focusableInput.select();
        } else if (isFunction(focusableInput.focus)) {
          focusableInput.focus();
        }
      }
    }
  }, [autoOpen, autoFocusEntry]);
  return jsx("div", {
    class: "bio-properties-panel-list-item",
    children: jsx(CollapsibleEntry, { ...props,
      open: autoOpen
    })
  });
}

const noop$3 = () => {};
/**
 * @param {import('../PropertiesPanel').ListGroupDefinition} props
 */


function ListGroup(props) {
  const {
    add,
    element,
    id,
    items,
    label,
    shouldOpen = true,
    shouldSort = true
  } = props;
  const groupRef = useRef(null);
  const [open, setOpen] = useLayoutState(['groups', id, 'open'], false);
  const [sticky, setSticky] = useState(false);
  const onShow = useCallback(() => setOpen(true), [setOpen]);
  const [ordering, setOrdering] = useState([]);
  const [newItemAdded, setNewItemAdded] = useState(false);
  const prevItems = usePrevious(items);
  const prevElement = usePrevious(element);
  const elementChanged = element !== prevElement;
  const shouldHandleEffects = !elementChanged && (shouldSort || shouldOpen); // reset initial ordering when element changes (before first render)

  if (elementChanged) {
    setOrdering(createOrdering(shouldSort ? sortItems(items) : items));
  } // keep ordering in sync to items - and open changes
  // (0) set initial ordering from given items


  useEffect(() => {
    if (!prevItems || !shouldSort) {
      setOrdering(createOrdering(items));
    }
  }, [items, element]); // (1) items were added

  useEffect(() => {
    if (shouldHandleEffects && prevItems && items.length > prevItems.length) {
      let add = [];
      items.forEach(item => {
        if (!ordering.includes(item.id)) {
          add.push(item.id);
        }
      });
      let newOrdering = ordering; // open if not open and configured

      if (!open && shouldOpen) {
        toggleOpen(); // if I opened and I should sort, then sort items

        if (shouldSort) {
          newOrdering = createOrdering(sortItems(items));
        }
      } // add new items on top or bottom depending on sorting behavior


      newOrdering = newOrdering.filter(item => !add.includes(item));

      if (shouldSort) {
        newOrdering.unshift(...add);
      } else {
        newOrdering.push(...add);
      }

      setOrdering(newOrdering);
      setNewItemAdded(true);
    } else {
      setNewItemAdded(false);
    }
  }, [items, open, shouldHandleEffects]); // (2) sort items on open if shouldSort is set

  useEffect(() => {
    if (shouldSort && open && !newItemAdded) {
      setOrdering(createOrdering(sortItems(items)));
    }
  }, [open, shouldSort]); // (3) items were deleted

  useEffect(() => {
    if (shouldHandleEffects && prevItems && items.length < prevItems.length) {
      let keep = [];
      ordering.forEach(o => {
        if (getItem(items, o)) {
          keep.push(o);
        }
      });
      setOrdering(keep);
    }
  }, [items, shouldHandleEffects]); // set css class when group is sticky to top

  useStickyIntersectionObserver(groupRef, 'div.bio-properties-panel-scroll-container', setSticky);

  const toggleOpen = () => setOpen(!open);

  const hasItems = !!items.length;
  const propertiesPanelContext = { ...useContext(LayoutContext),
    onShow
  };
  return jsxs("div", {
    class: "bio-properties-panel-group",
    "data-group-id": 'group-' + id,
    ref: groupRef,
    children: [jsxs("div", {
      class: classnames('bio-properties-panel-group-header', hasItems ? '' : 'empty', hasItems && open ? 'open' : '', sticky && open ? 'sticky' : ''),
      onClick: hasItems ? toggleOpen : noop$3,
      children: [jsx("div", {
        title: label,
        class: "bio-properties-panel-group-header-title",
        children: label
      }), jsxs("div", {
        class: "bio-properties-panel-group-header-buttons",
        children: [add ? jsxs("button", {
          title: "Create new list item",
          class: "bio-properties-panel-group-header-button bio-properties-panel-add-entry",
          onClick: add,
          children: [jsx(CreateIcon, {}), !hasItems ? jsx("span", {
            class: "bio-properties-panel-add-entry-label",
            children: "Create"
          }) : null]
        }) : null, hasItems ? jsx("div", {
          title: `List contains ${items.length} item${items.length != 1 ? 's' : ''}`,
          class: "bio-properties-panel-list-badge",
          children: items.length
        }) : null, hasItems ? jsx("button", {
          title: "Toggle section",
          class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
          children: jsx(ArrowIcon, {
            class: open ? 'bio-properties-panel-arrow-down' : 'bio-properties-panel-arrow-right'
          })
        }) : null]
      })]
    }), jsx("div", {
      class: classnames('bio-properties-panel-list', open && hasItems ? 'open' : ''),
      children: jsx(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: ordering.map((o, index) => {
          const item = getItem(items, o);

          if (!item) {
            return;
          }

          const {
            id
          } = item; // if item was added, open first or last item based on ordering

          const autoOpen = newItemAdded && (shouldSort ? index === 0 : index === ordering.length - 1);
          return createElement(ListItem, { ...item,
            autoOpen: autoOpen,
            element: element,
            index: index,
            key: id
          });
        })
      })
    })]
  });
} // helpers ////////////////////

/**
 * Sorts given items alphanumeric by label
 */


function sortItems(items) {
  return sortBy(items, i => i.label.toLowerCase());
}

function getItem(items, id) {
  return find(items, i => i.id === id);
}

function createOrdering(items) {
  return items.map(i => i.id);
}

function Description$1(props) {
  const {
    element,
    forId,
    value
  } = props;
  const contextDescription = useDescriptionContext(forId, element);
  const description = value || contextDescription;

  if (description) {
    return jsx("div", {
      class: "bio-properties-panel-description",
      children: description
    });
  }
}

const noop$2 = () => {};

function Checkbox(props) {
  const {
    id,
    label,
    onChange,
    disabled,
    value = false,
    show = noop$2
  } = props;

  const handleChange = ({
    target
  }) => {
    onChange(target.checked);
  };

  const ref = useShowEntryEvent(show);
  return jsxs("div", {
    class: "bio-properties-panel-checkbox",
    children: [jsx("input", {
      ref: ref,
      id: prefixId$6(id),
      name: id,
      type: "checkbox",
      class: "bio-properties-panel-input",
      onChange: handleChange,
      checked: value,
      disabled: disabled
    }), jsx("label", {
      for: prefixId$6(id),
      class: "bio-properties-panel-label",
      children: label
    })]
  });
}
/**
 * @param {Object} props
 * @param {Object} props.element
 * @param {String} props.id
 * @param {String} props.description
 * @param {String} props.label
 * @param {Function} props.getValue
 * @param {Function} props.setValue
 * @param {boolean} [props.disabled]
 */


function CheckboxEntry(props) {
  const {
    element,
    id,
    description,
    label,
    getValue,
    setValue,
    disabled,
    show = noop$2
  } = props;
  const value = getValue(element);
  const error = useShowErrorEvent(show);
  return jsxs("div", {
    class: "bio-properties-panel-entry bio-properties-panel-checkbox-entry",
    "data-entry-id": id,
    children: [jsx(Checkbox, {
      disabled: disabled,
      id: id,
      label: label,
      onChange: setValue,
      show: show,
      value: value
    }), error && jsx("div", {
      class: "bio-properties-panel-error",
      children: error
    }), jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}

function isEdited$6(node) {
  return node && !!node.checked;
} // helpers /////////////////


function prefixId$6(id) {
  return `bio-properties-panel-${id}`;
}

function NumberField(props) {
  const {
    debounce,
    disabled,
    id,
    label,
    max,
    min,
    onInput,
    step,
    value = ''
  } = props;
  const handleInput = useMemo(() => {
    return debounce(event => {
      const {
        validity,
        value
      } = event.target;

      if (validity.valid) {
        onInput(value ? parseFloat(value) : undefined);
      }
    });
  }, [onInput, debounce]);
  return jsxs("div", {
    class: "bio-properties-panel-numberfield",
    children: [jsx("label", {
      for: prefixId$5(id),
      class: "bio-properties-panel-label",
      children: label
    }), jsx("input", {
      id: prefixId$5(id),
      type: "number",
      name: id,
      spellCheck: "false",
      autoComplete: "off",
      disabled: disabled,
      class: "bio-properties-panel-input",
      max: max,
      min: min,
      onInput: handleInput,
      step: step,
      value: value
    })]
  });
}
/**
 * @param {Object} props
 * @param {Boolean} props.debounce
 * @param {String} props.description
 * @param {Boolean} props.disabled
 * @param {Object} props.element
 * @param {Function} props.getValue
 * @param {String} props.id
 * @param {String} props.label
 * @param {String} props.max
 * @param {String} props.min
 * @param {Function} props.setValue
 * @param {String} props.step
 */


function NumberFieldEntry(props) {
  const {
    debounce,
    description,
    disabled,
    element,
    getValue,
    id,
    label,
    max,
    min,
    setValue,
    step
  } = props;
  const value = getValue(element);
  return jsxs("div", {
    class: "bio-properties-panel-entry",
    "data-entry-id": id,
    children: [jsx(NumberField, {
      debounce: debounce,
      disabled: disabled,
      id: id,
      label: label,
      onInput: setValue,
      max: max,
      min: min,
      step: step,
      value: value
    }), jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}

function isEdited$5(node) {
  return node && !!node.value;
} // helpers /////////////////


function prefixId$5(id) {
  return `bio-properties-panel-${id}`;
}

const noop$1 = () => {};
/**
 * @typedef { { value: string, label: string, disabled: boolean } } Option
 */

/**
 * Provides basic select input.
 *
 * @param {object} props
 * @param {string} props.id
 * @param {string[]} props.path
 * @param {string} props.label
 * @param {Function} props.onChange
 * @param {Array<Option>} [props.options]
 * @param {string} props.value
 * @param {boolean} [props.disabled]
 */


function Select(props) {
  const {
    id,
    label,
    onChange,
    options = [],
    value,
    disabled,
    show = noop$1
  } = props;
  const ref = useShowEntryEvent(show);

  const handleChange = ({
    target
  }) => {
    onChange(target.value);
  };

  return jsxs("div", {
    class: "bio-properties-panel-select",
    children: [jsx("label", {
      for: prefixId$4(id),
      class: "bio-properties-panel-label",
      children: label
    }), jsx("select", {
      ref: ref,
      id: prefixId$4(id),
      name: id,
      class: "bio-properties-panel-input",
      onInput: handleChange,
      value: value,
      disabled: disabled,
      children: options.map((option, idx) => {
        return jsx("option", {
          value: option.value,
          disabled: option.disabled,
          children: option.label
        }, idx);
      })
    })]
  });
}
/**
 * @param {object} props
 * @param {object} props.element
 * @param {string} props.id
 * @param {string} [props.description]
 * @param {string} props.label
 * @param {Function} props.getValue
 * @param {Function} props.setValue
 * @param {Function} props.getOptions
 * @param {boolean} [props.disabled]
 */


function SelectEntry(props) {
  const {
    element,
    id,
    description,
    label,
    getValue,
    setValue,
    getOptions,
    disabled,
    show = noop$1
  } = props;
  const value = getValue(element);
  const options = getOptions(element);
  const error = useShowErrorEvent(show);
  return jsxs("div", {
    class: classnames('bio-properties-panel-entry', error ? 'has-error' : ''),
    "data-entry-id": id,
    children: [jsx(Select, {
      id: id,
      label: label,
      value: value,
      onChange: setValue,
      options: options,
      disabled: disabled,
      show: show
    }), error && jsx("div", {
      class: "bio-properties-panel-error",
      children: error
    }), jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}

function isEdited$4(node) {
  return node && !!node.value;
} // helpers /////////////////


function prefixId$4(id) {
  return `bio-properties-panel-${id}`;
}

function FeelIcon(props) {
  const {
    label,
    feel = false
  } = props;
  const feelRequiredLabel = ' must be a FEEL expression';
  const feelOptionalLabel = ' can optionally be a FEEL expression';
  return jsx("i", {
    class: "bio-properties-panel-feel-icon",
    title: label + (feel === 'required' ? feelRequiredLabel : feelOptionalLabel),
    children: feel === 'required' ? jsx(FeelRequiredIcon, {}) : jsx(FeelOptionalIcon, {})
  });
}

function TextArea(props) {
  const {
    id,
    label,
    rows = 2,
    debounce,
    feel,
    onInput,
    value = '',
    disabled,
    monospace
  } = props;
  const handleInput = useMemo(() => {
    return debounce(({
      target
    }) => onInput(target.value.length ? target.value : undefined));
  }, [onInput, debounce]);
  return jsxs("div", {
    class: "bio-properties-panel-textarea",
    children: [jsxs("label", {
      for: prefixId$2(id),
      class: "bio-properties-panel-label",
      children: [label, feel && jsx(FeelIcon, {
        feel: feel,
        label: label
      })]
    }), jsx("textarea", {
      id: prefixId$2(id),
      name: id,
      spellCheck: "false",
      class: classnames('bio-properties-panel-input', monospace ? 'bio-properties-panel-input-monospace' : ''),
      onInput: handleInput,
      onFocus: props.onFocus,
      onBlur: props.onBlur,
      rows: rows,
      value: value,
      disabled: disabled
    })]
  });
}
/**
 * @param {object} props
 * @param {object} props.element
 * @param {string} props.id
 * @param {string} props.description
 * @param {boolean} props.debounce
 * @param {string} props.label
 * @param {Function} props.getValue
 * @param {Function} props.setValue
 * @param {number} props.rows
 * @param {boolean} props.monospace
 * @param {boolean} [props.disabled]
 */


function TextAreaEntry(props) {
  const {
    element,
    id,
    description,
    debounce,
    feel,
    label,
    getValue,
    setValue,
    rows,
    monospace,
    disabled
  } = props;
  const value = getValue(element);
  return jsxs("div", {
    class: "bio-properties-panel-entry",
    "data-entry-id": id,
    children: [jsx(TextArea, {
      id: id,
      label: label,
      value: value,
      onInput: setValue,
      rows: rows,
      debounce: debounce,
      monospace: monospace,
      feel: feel,
      disabled: disabled
    }), jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}

function isEdited$2(node) {
  return node && !!node.value;
} // helpers /////////////////


function prefixId$2(id) {
  return `bio-properties-panel-${id}`;
}

const noop = () => {};

function Textfield(props) {
  const {
    debounce,
    disabled = false,
    id,
    label,
    onInput,
    feel = false,
    value = '',
    show = noop
  } = props;
  const ref = useShowEntryEvent(show);
  const handleInput = useMemo(() => {
    return debounce(({
      target
    }) => onInput(target.value.length ? target.value : undefined));
  }, [onInput, debounce]);
  return jsxs("div", {
    class: "bio-properties-panel-textfield",
    children: [jsxs("label", {
      for: prefixId$1(id),
      class: "bio-properties-panel-label",
      children: [label, feel && jsx(FeelIcon, {
        feel: feel,
        label: label
      })]
    }), jsx("input", {
      ref: ref,
      id: prefixId$1(id),
      type: "text",
      name: id,
      spellCheck: "false",
      autoComplete: "off",
      disabled: disabled,
      class: "bio-properties-panel-input",
      onInput: handleInput,
      onFocus: props.onFocus,
      onBlur: props.onBlur,
      value: value || ''
    })]
  });
}
/**
 * @param {Object} props
 * @param {Object} props.element
 * @param {String} props.id
 * @param {String} props.description
 * @param {Boolean} props.debounce
 * @param {Boolean} props.disabled
 * @param {String} props.label
 * @param {Function} props.getValue
 * @param {Function} props.setValue
 * @param {Function} props.validate
 */


function TextfieldEntry(props) {
  const {
    element,
    id,
    description,
    debounce,
    disabled,
    feel,
    label,
    getValue,
    setValue,
    validate,
    show = noop
  } = props;
  const [cachedInvalidValue, setCachedInvalidValue] = useState(null);
  const [validationError, setValidationError] = useState(null);
  let value = getValue(element);
  const previousValue = usePrevious(value);
  useEffect(() => {
    if (isFunction(validate)) {
      const newValidationError = validate(value) || null;
      setValidationError(newValidationError);
    }
  }, [value]);

  const onInput = newValue => {
    let newValidationError = null;

    if (isFunction(validate)) {
      newValidationError = validate(newValue) || null;
    }

    if (newValidationError) {
      setCachedInvalidValue(newValue);
    } else {
      setValue(newValue);
    }

    setValidationError(newValidationError);
  };

  if (previousValue === value && validationError) {
    value = cachedInvalidValue;
  }

  const temporaryError = useShowErrorEvent(show);
  const error = temporaryError || validationError;
  return jsxs("div", {
    class: classnames('bio-properties-panel-entry', error ? 'has-error' : ''),
    "data-entry-id": id,
    children: [jsx(Textfield, {
      debounce: debounce,
      disabled: disabled,
      feel: feel,
      id: id,
      label: label,
      onInput: onInput,
      show: show,
      value: value
    }), error && jsx("div", {
      class: "bio-properties-panel-error",
      children: error
    }), jsx(Description$1, {
      forId: id,
      element: element,
      value: description
    })]
  });
}

function isEdited$1(node) {
  return node && !!node.value;
} // helpers /////////////////


function prefixId$1(id) {
  return `bio-properties-panel-${id}`;
}

/**
 * @param {string} type
 * @param {boolean} [strict]
 *
 * @returns {any}
 */

function getService(type, strict) {}

const PropertiesPanelContext = createContext({
  getService
});

function arrayAdd(array, index, item) {
  const copy = [...array];
  copy.splice(index, 0, item);
  return copy;
}
function textToLabel(text = '...') {
  if (text.length > 10) {
    return `${text.substring(0, 30)}...`;
  }

  return text;
}
const INPUTS = ['checkbox', 'checklist', 'number', 'radio', 'select', 'taglist', 'textfield'];
const VALUES_INPUTS = ['checklist', 'radio', 'select', 'taglist'];

const labelsByType = {
  button: 'BUTTON',
  checkbox: 'CHECKBOX',
  checklist: 'CHECKLIST',
  columns: 'COLUMNS',
  default: 'FORM',
  number: 'NUMBER',
  radio: 'RADIO',
  select: 'SELECT',
  taglist: 'TAGLIST',
  text: 'TEXT',
  textfield: 'TEXT FIELD'
};
const PropertiesPanelHeaderProvider = {
  getElementLabel: field => {
    const {
      type
    } = field;

    if (type === 'text') {
      return textToLabel(field.text);
    }

    if (type === 'default') {
      return field.id;
    }

    return field.label;
  },
  getElementIcon: field => {
    const {
      type
    } = field;
    const Icon = iconsByType[type];

    if (Icon) {
      return () => jsx(Icon, {
        width: "36",
        height: "36",
        viewBox: "0 0 54 54"
      });
    }
  },
  getTypeLabel: field => {
    const {
      type
    } = field;
    return labelsByType[type];
  }
};

/**
 * Provide placeholders for empty and multiple state.
 */
const PropertiesPanelPlaceholderProvider = {
  getEmpty: () => {
    return {
      text: 'Select a form field to edit its properties.'
    };
  },
  getMultiple: () => {
    return {
      text: 'Multiple form fields are selected. Select a single form field to edit its properties.'
    };
  }
};

function ActionEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];

  if (type === 'button') {
    entries.push({
      id: 'action',
      component: Action,
      editField: editField,
      field: field,
      isEdited: isEdited$4
    });
  }

  return entries;
}

function Action(props) {
  const {
    editField,
    field,
    id
  } = props;
  const path = ['action'];

  const getValue = () => {
    return get(field, path, '');
  };

  const setValue = value => {
    return editField(field, path, value);
  };

  const getOptions = () => [{
    label: 'Submit',
    value: 'submit'
  }, {
    label: 'Reset',
    value: 'reset'
  }];

  return SelectEntry({
    element: field,
    getOptions,
    getValue,
    id,
    label: 'Action',
    setValue
  });
}

function useService (type, strict) {
  const {
    getService
  } = useContext(PropertiesPanelContext);
  return getService(type, strict);
}

function ColumnsEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];

  if (type === 'columns') {
    entries.push({
      id: 'columns',
      component: Columns,
      editField: editField,
      field: field,
      isEdited: isEdited$5
    });
  }

  return entries;
}

function Columns(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');

  const getValue = () => {
    return field.components.length;
  };

  const setValue = value => {
    let components = field.components.slice();

    if (value > components.length) {
      while (value > components.length) {
        components.push(Default.create({
          _parent: field.id
        }));
      }
    } else {
      components = components.slice(0, value);
    }

    editField(field, 'components', components);
  };

  return NumberFieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Columns',
    setValue
  });
}

function DescriptionEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];

  if (INPUTS.includes(type)) {
    entries.push({
      id: 'description',
      component: Description,
      editField: editField,
      field: field,
      isEdited: isEdited$1
    });
  }

  return entries;
}

function Description(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');
  const path = ['description'];

  const getValue = () => {
    return get(field, path, '');
  };

  const setValue = value => {
    return editField(field, path, value);
  };

  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Field description',
    setValue
  });
}

function DefaultOptionEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = []; // Only make default values available when they are statically defined

  if (!INPUTS.includes(type) || VALUES_INPUTS.includes(type) && !field.values) {
    return entries;
  }

  const defaultOptions = {
    editField,
    field,
    id: 'defaultValue',
    label: 'Default value'
  };

  if (type === 'checkbox') {
    entries.push({ ...defaultOptions,
      component: DefaultValueCheckbox,
      isEdited: isEdited$4
    });
  }

  if (type === 'number') {
    entries.push({ ...defaultOptions,
      component: DefaultValueNumber,
      isEdited: isEdited$5
    });
  }

  if (type === 'radio' || type === 'select') {
    entries.push({ ...defaultOptions,
      component: DefaultValueSingleSelect,
      isEdited: isEdited$4
    });
  } // todo(Skaiir): implement a multiselect equivalent (cf. https://github.com/bpmn-io/form-js/issues/265)


  if (type === 'textfield') {
    entries.push({ ...defaultOptions,
      component: DefaultValueTextfield,
      isEdited: isEdited$1
    });
  }

  return entries;
}

function DefaultValueCheckbox(props) {
  const {
    editField,
    field,
    id,
    label
  } = props;
  const {
    defaultValue
  } = field;
  const path = ['defaultValue'];

  const getOptions = () => {
    return [{
      label: 'Checked',
      value: 'true'
    }, {
      label: 'Not checked',
      value: 'false'
    }];
  };

  const setValue = value => {
    return editField(field, path, parseStringToBoolean(value));
  };

  const getValue = () => {
    return parseBooleanToString(defaultValue);
  };

  return SelectEntry({
    element: field,
    getOptions,
    getValue,
    id,
    label,
    setValue
  });
}

function DefaultValueNumber(props) {
  const {
    editField,
    field,
    id,
    label
  } = props;
  const debounce = useService('debounce');
  const path = ['defaultValue'];

  const getValue = () => {
    return get(field, path, '');
  };

  const setValue = value => {
    return editField(field, path, value);
  };

  return NumberFieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label,
    setValue
  });
}

function DefaultValueSingleSelect(props) {
  const {
    editField,
    field,
    id,
    label
  } = props;
  const {
    defaultValue,
    values = []
  } = field;
  const path = ['defaultValue'];

  const getOptions = () => {
    return [{
      label: '<none>'
    }, ...values];
  };

  const setValue = value => {
    return editField(field, path, value.length ? value : undefined);
  };

  const getValue = () => {
    return defaultValue;
  };

  return SelectEntry({
    element: field,
    getOptions,
    getValue,
    id,
    label,
    setValue
  });
}

function DefaultValueTextfield(props) {
  const {
    editField,
    field,
    id,
    label
  } = props;
  const debounce = useService('debounce');
  const path = ['defaultValue'];

  const getValue = () => {
    return get(field, path, '');
  };

  const setValue = value => {
    return editField(field, path, value);
  };

  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label,
    setValue
  });
} // helpers /////////////////


function parseStringToBoolean(value) {
  if (value === 'true') {
    return true;
  }

  return false;
}

function parseBooleanToString(value) {
  if (value === true) {
    return 'true';
  }

  return 'false';
}

function DisabledEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];

  if (INPUTS.includes(type)) {
    entries.push({
      id: 'disabled',
      component: Disabled,
      editField: editField,
      field: field,
      isEdited: isEdited$6
    });
  }

  return entries;
}

function Disabled(props) {
  const {
    editField,
    field,
    id
  } = props;
  const path = ['disabled'];

  const getValue = () => {
    return get(field, path, '');
  };

  const setValue = value => {
    return editField(field, path, value);
  };

  return CheckboxEntry({
    element: field,
    getValue,
    id,
    label: 'Disabled',
    setValue
  });
}

function IdEntry(props) {
  const {
    editField,
    field
  } = props;
  const entries = [];

  if (field.type === 'default') {
    entries.push({
      id: 'id',
      component: Id,
      editField: editField,
      field: field,
      isEdited: isEdited$1
    });
  }

  return entries;
}

function Id(props) {
  const {
    editField,
    field,
    id
  } = props;
  const formFieldRegistry = useService('formFieldRegistry');
  const debounce = useService('debounce');
  const path = ['id'];

  const getValue = () => {
    return get(field, path, '');
  };

  const setValue = value => {
    return editField(field, path, value);
  };

  const validate = value => {
    if (isUndefined(value) || !value.length) {
      return 'Must not be empty.';
    }

    const assigned = formFieldRegistry._ids.assigned(value);

    if (assigned && assigned !== field) {
      return 'Must be unique.';
    }

    return validateId(value) || null;
  };

  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'ID',
    setValue,
    validate
  });
} // id structural validation /////////////


const SPACE_REGEX = /\s/; // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar

const QNAME_REGEX = /^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i; // for ID validation as per BPMN Schema (QName - Namespace)

const ID_REGEX = /^[a-z_][\w-.]*$/i;

function validateId(idValue) {
  if (containsSpace(idValue)) {
    return 'Must not contain spaces.';
  }

  if (!ID_REGEX.test(idValue)) {
    if (QNAME_REGEX.test(idValue)) {
      return 'Must not contain prefix.';
    }

    return 'Must be a valid QName.';
  }
}

function containsSpace(value) {
  return SPACE_REGEX.test(value);
}

function KeyEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];

  if (INPUTS.includes(type)) {
    entries.push({
      id: 'key',
      component: Key$1,
      editField: editField,
      field: field,
      isEdited: isEdited$1
    });
  }

  return entries;
}

function Key$1(props) {
  const {
    editField,
    field,
    id
  } = props;
  const formFieldRegistry = useService('formFieldRegistry');
  const debounce = useService('debounce');
  const path = ['key'];

  const getValue = () => {
    return get(field, path, '');
  };

  const setValue = value => {
    return editField(field, path, value);
  };

  const validate = value => {
    if (isUndefined(value) || !value.length) {
      return 'Must not be empty.';
    }

    if (/\s/.test(value)) {
      return 'Must not contain spaces.';
    }

    const assigned = formFieldRegistry._keys.assigned(value);

    if (assigned && assigned !== field) {
      return 'Must be unique.';
    }

    return null;
  };

  return TextfieldEntry({
    debounce,
    description: 'Binds to a form variable',
    element: field,
    getValue,
    id,
    label: 'Key',
    setValue,
    validate
  });
}

function LabelEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];

  if (INPUTS.includes(type) || type === 'button') {
    entries.push({
      id: 'label',
      component: Label$1,
      editField: editField,
      field: field,
      isEdited: isEdited$1
    });
  }

  return entries;
}

function Label$1(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');
  const path = ['label'];

  const getValue = () => {
    return get(field, path, '');
  };

  const setValue = value => {
    return editField(field, path, value);
  };

  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Field label',
    setValue
  });
}

function TextEntry(props) {
  const {
    editField,
    field
  } = props;
  const {
    type
  } = field;
  const entries = [];

  if (type === 'text') {
    entries.push({
      id: 'text',
      component: Text,
      editField: editField,
      field: field,
      isEdited: isEdited$2
    });
  }

  return entries;
}

function Text(props) {
  const {
    editField,
    field,
    id
  } = props;
  const debounce = useService('debounce');
  const path = ['text'];

  const getValue = () => {
    return get(field, path, '');
  };

  const setValue = value => {
    return editField(field, path, value);
  };

  return TextAreaEntry({
    debounce,
    description: 'Use Markdown or basic HTML to format.',
    element: field,
    getValue,
    id,
    label: 'Text',
    rows: 10,
    setValue
  });
}

function ValueEntry(props) {
  const {
    editField,
    field,
    idPrefix,
    index,
    validateFactory
  } = props;
  const entries = [{
    component: Label,
    editField,
    field,
    id: idPrefix + '-label',
    idPrefix,
    index,
    validateFactory
  }, {
    component: Value$1,
    editField,
    field,
    id: idPrefix + '-value',
    idPrefix,
    index,
    validateFactory
  }];
  return entries;
}

function Label(props) {
  const {
    editField,
    field,
    id,
    index,
    validateFactory
  } = props;
  const debounce = useService('debounce');

  const setValue = value => {
    const values = get(field, ['values']);
    return editField(field, 'values', set(values, [index, 'label'], value));
  };

  const getValue = () => {
    return get(field, ['values', index, 'label']);
  };

  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Label',
    setValue,
    validate: validateFactory(getValue())
  });
}

function Value$1(props) {
  const {
    editField,
    field,
    id,
    index,
    validateFactory
  } = props;
  const debounce = useService('debounce');

  const setValue = value => {
    const values = get(field, ['values']);
    return editField(field, 'values', set(values, [index, 'value'], value));
  };

  const getValue = () => {
    return get(field, ['values', index, 'value']);
  };

  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Value',
    setValue,
    validate: validateFactory(getValue())
  });
}

function CustomValueEntry(props) {
  const {
    editField,
    field,
    idPrefix,
    index,
    validateFactory
  } = props;
  const entries = [{
    component: Key,
    editField,
    field,
    id: idPrefix + '-key',
    idPrefix,
    index,
    validateFactory
  }, {
    component: Value,
    editField,
    field,
    id: idPrefix + '-value',
    idPrefix,
    index,
    validateFactory
  }];
  return entries;
}

function Key(props) {
  const {
    editField,
    field,
    id,
    index,
    validateFactory
  } = props;
  const debounce = useService('debounce');

  const setValue = value => {
    const properties = get(field, ['properties']);
    const key = Object.keys(properties)[index];
    return editField(field, 'properties', updateKey(properties, key, value));
  };

  const getValue = () => {
    return Object.keys(get(field, ['properties']))[index];
  };

  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Key',
    setValue,
    validate: validateFactory(getValue())
  });
}

function Value(props) {
  const {
    editField,
    field,
    id,
    index,
    validateFactory
  } = props;
  const debounce = useService('debounce');

  const setValue = value => {
    const properties = get(field, ['properties']);
    const key = Object.keys(properties)[index];
    editField(field, 'properties', updateValue(properties, key, value));
  };

  const getValue = () => {
    const properties = get(field, ['properties']);
    const key = Object.keys(properties)[index];
    return get(field, ['properties', key]);
  };

  return TextfieldEntry({
    debounce,
    element: field,
    getValue,
    id,
    label: 'Value',
    setValue,
    validate: validateFactory(getValue())
  });
} // helpers //////////

/**
 * Returns copy of object with updated value.
 *
 * @param {Object} properties
 * @param {string} key
 * @param {string} value
 *
 * @returns {Object}
 */


function updateValue(properties, key, value) {
  return { ...properties,
    [key]: value
  };
}
/**
 * Returns copy of object with updated key.
 *
 * @param {Object} properties
 * @param {string} oldKey
 * @param {string} newKey
 *
 * @returns {Object}
 */


function updateKey(properties, oldKey, newKey) {
  return Object.entries(properties).reduce((newProperties, entry) => {
    const [key, value] = entry;
    return { ...newProperties,
      [key === oldKey ? newKey : key]: value
    };
  }, {});
}

const VALUES_SOURCES = {
  STATIC: 'static',
  INPUT: 'input'
};
const VALUES_SOURCE_DEFAULT = VALUES_SOURCES.STATIC;
const VALUES_SOURCES_LABELS = {
  [VALUES_SOURCES.STATIC]: 'Static',
  [VALUES_SOURCES.INPUT]: 'Input data'
};
const VALUES_SOURCES_PATHS = {
  [VALUES_SOURCES.STATIC]: ['values'],
  [VALUES_SOURCES.INPUT]: ['valuesKey']
};
const VALUES_SOURCES_DEFAULTS = {
  [VALUES_SOURCES.STATIC]: [],
  [VALUES_SOURCES.INPUT]: ''
}; // helpers ///////////////////

function getValuesSource(field) {
  for (const source of Object.values(VALUES_SOURCES)) {
    if (get(field, VALUES_SOURCES_PATHS[source]) !== undefined) {
      return source;
    }
  }

  return VALUES_SOURCE_DEFAULT;
}

function ValuesSourceSelectEntry(props) {
  const {
    editField,
    field,
    id
  } = props;
  return [{
    id: id + '-select',
    component: ValuesSourceSelect,
    isEdited: isEdited$4,
    editField,
    field
  }];
}

function ValuesSourceSelect(props) {
  const {
    editField,
    field,
    id
  } = props;
  const getValue = getValuesSource;

  const setValue = value => {
    let newField = field;
    Object.values(VALUES_SOURCES).forEach(source => {
      // Clear all values source definitions and default the newly selected one
      const newValue = value === source ? VALUES_SOURCES_DEFAULTS[source] : undefined;
      newField = editField(field, VALUES_SOURCES_PATHS[source], newValue);
    });
    return newField;
  };

  const getValuesSourceOptions = () => {
    return Object.values(VALUES_SOURCES).map(valueSource => ({
      label: VALUES_SOURCES_LABELS[valueSource],
      value: valueSource
    }));
  };

  return SelectEntry({
    label: 'Type',
    element: field,
    getOptions: getValuesSourceOptions,
    getValue,
    id,
    setValue
  });
}

function InputKeyValuesSourceEntry(props) {
  const {
    editField,
    field,
    id
  } = props;
  return [{
    id: id + '-key',
    component: InputValuesKey,
    label: 'Input values key',
    description: 'Define which input property to populate the values from',
    isEdited: isEdited$1,
    editField,
    field
  }];
}

function InputValuesKey(props) {
  const {
    editField,
    field,
    id,
    label,
    description
  } = props;
  const debounce = useService('debounce');
  const path = VALUES_SOURCES_PATHS[VALUES_SOURCES.INPUT];

  const getValue = () => get(field, path, '');

  const setValue = value => editField(field, path, value || '');

  return TextfieldEntry({
    debounce,
    description,
    element: field,
    getValue,
    id,
    label,
    setValue
  });
}

function StaticValuesSourceEntry(props) {
  const {
    editField,
    field,
    id: idPrefix
  } = props;
  const {
    values
  } = field;

  const addEntry = e => {
    e.stopPropagation();
    const index = values.length + 1;
    const entry = {
      label: `Value ${index}`,
      value: `value${index}`
    };
    editField(field, VALUES_SOURCES_PATHS[VALUES_SOURCES.STATIC], arrayAdd(values, values.length, entry));
  };

  const removeEntry = entry => {
    editField(field, VALUES_SOURCES_PATHS[VALUES_SOURCES.STATIC], without(values, entry));
  };

  const validateFactory = key => {
    return value => {
      if (value === key) {
        return;
      }

      if (isUndefined(value) || !value.length) {
        return 'Must not be empty.';
      }

      const isValueAssigned = values.find(entry => entry.value === value);

      if (isValueAssigned) {
        return 'Must be unique.';
      }
    };
  };

  const items = values.map((entry, index) => {
    const id = idPrefix + '-' + index;
    return {
      id,
      label: entry.label,
      entries: ValueEntry({
        editField,
        field,
        idPrefix: id,
        index,
        validateFactory
      }),
      autoFocusEntry: id + '-label',
      remove: () => removeEntry(entry)
    };
  });
  return {
    items,
    add: addEntry
  };
}

function GeneralGroup(field, editField) {
  const entries = [...IdEntry({
    field,
    editField
  }), ...LabelEntry({
    field,
    editField
  }), ...DescriptionEntry({
    field,
    editField
  }), ...KeyEntry({
    field,
    editField
  }), ...DefaultOptionEntry({
    field,
    editField
  }), ...ActionEntry({
    field,
    editField
  }), ...ColumnsEntry({
    field,
    editField
  }), ...TextEntry({
    field,
    editField
  }), ...DisabledEntry({
    field,
    editField
  })];
  return {
    id: 'general',
    label: 'General',
    entries
  };
}

function ValidationGroup(field, editField) {
  const {
    type
  } = field;

  if (!(INPUTS.includes(type) && type !== 'checkbox' && type !== 'checklist' && type !== 'taglist')) {
    return null;
  }

  const onChange = key => {
    return value => {
      const validate = get(field, ['validate'], {});
      editField(field, ['validate'], set(validate, [key], value));
    };
  };

  const getValue = key => {
    return () => {
      return get(field, ['validate', key]);
    };
  };

  let entries = [{
    id: 'required',
    component: Required,
    getValue,
    field,
    isEdited: isEdited$6,
    onChange
  }];

  if (type === 'textfield') {
    entries.push({
      id: 'minLength',
      component: MinLength,
      getValue,
      field,
      isEdited: isEdited$5,
      onChange
    }, {
      id: 'maxLength',
      component: MaxLength,
      getValue,
      field,
      isEdited: isEdited$5,
      onChange
    }, {
      id: 'pattern',
      component: Pattern,
      getValue,
      field,
      isEdited: isEdited$1,
      onChange
    });
  }

  if (type === 'number') {
    entries.push({
      id: 'min',
      component: Min,
      getValue,
      field,
      isEdited: isEdited$5,
      onChange
    }, {
      id: 'max',
      component: Max,
      getValue,
      field,
      isEdited: isEdited$5,
      onChange
    });
  }

  return {
    id: 'validation',
    label: 'Validation',
    entries
  };
}

function Required(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  return CheckboxEntry({
    element: field,
    getValue: getValue('required'),
    id,
    label: 'Required',
    setValue: onChange('required')
  });
}

function MinLength(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  return NumberFieldEntry({
    debounce,
    element: field,
    getValue: getValue('minLength'),
    id,
    label: 'Minimum length',
    min: 0,
    setValue: onChange('minLength')
  });
}

function MaxLength(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  return NumberFieldEntry({
    debounce,
    element: field,
    getValue: getValue('maxLength'),
    id,
    label: 'Maximum length',
    min: 0,
    setValue: onChange('maxLength')
  });
}

function Pattern(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  return TextfieldEntry({
    debounce,
    element: field,
    getValue: getValue('pattern'),
    id,
    label: 'Regular expression pattern',
    setValue: onChange('pattern')
  });
}

function Min(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  return NumberFieldEntry({
    debounce,
    element: field,
    getValue: getValue('min'),
    id,
    label: 'Minimum',
    min: 0,
    setValue: onChange('min')
  });
}

function Max(props) {
  const {
    field,
    getValue,
    id,
    onChange
  } = props;
  const debounce = useService('debounce');
  return NumberFieldEntry({
    debounce,
    element: field,
    getValue: getValue('max'),
    id,
    label: 'Maximum',
    min: 0,
    setValue: onChange('max')
  });
}

function ValuesGroups(field, editField) {
  const {
    type,
    id: fieldId
  } = field;

  if (!VALUES_INPUTS.includes(type)) {
    return [];
  }

  const context = {
    editField,
    field
  };
  const valuesSourceId = `${fieldId}-valuesSource`;
  /**
   * @type {Array<Group|ListGroup>}
   */

  const groups = [{
    id: valuesSourceId,
    label: 'Options source',
    component: Group,
    entries: ValuesSourceSelectEntry({ ...context,
      id: valuesSourceId
    })
  }];
  const valuesSource = getValuesSource(field);

  if (valuesSource === VALUES_SOURCES.INPUT) {
    const dynamicValuesId = `${fieldId}-dynamicValues`;
    groups.push({
      id: dynamicValuesId,
      label: 'Dynamic options',
      component: Group,
      entries: InputKeyValuesSourceEntry({ ...context,
        id: dynamicValuesId
      })
    });
  } else if (valuesSource === VALUES_SOURCES.STATIC) {
    const staticValuesId = `${fieldId}-staticValues`;
    groups.push({
      id: staticValuesId,
      label: 'Static options',
      component: ListGroup,
      ...StaticValuesSourceEntry({ ...context,
        id: staticValuesId
      })
    });
  }

  return groups;
}

function CustomValuesGroup(field, editField) {
  const {
    properties = {},
    type
  } = field;

  if (type === 'default') {
    return null;
  }

  const addEntry = event => {
    event.stopPropagation();
    const index = Object.keys(properties).length + 1;
    const key = `key${index}`,
          value = 'value';
    editField(field, ['properties'], { ...properties,
      [key]: value
    });
  };

  const validateFactory = key => {
    return value => {
      if (value === key) {
        return;
      }

      if (isUndefined(value) || !value.length) {
        return 'Must not be empty.';
      }

      if (has(properties, value)) {
        return 'Must be unique.';
      }
    };
  };

  const items = Object.keys(properties).map((key, index) => {
    const removeEntry = event => {
      event.stopPropagation();
      return editField(field, ['properties'], removeKey(properties, key));
    };

    const id = `${field.id}-property-${index}`;
    return {
      autoFocusEntry: id + '-key',
      entries: CustomValueEntry({
        editField,
        field,
        idPrefix: id,
        index,
        validateFactory
      }),
      id,
      label: key || '',
      remove: removeEntry
    };
  });
  return {
    add: addEntry,
    component: ListGroup,
    id: 'custom-values',
    items,
    label: 'Custom properties',
    shouldSort: false
  };
} // helpers //////////

/**
 * Returns copy of object without key.
 *
 * @param {Object} properties
 * @param {string} oldKey
 *
 * @returns {Object}
 */

function removeKey(properties, oldKey) {
  return Object.entries(properties).reduce((newProperties, entry) => {
    const [key, value] = entry;

    if (key === oldKey) {
      return newProperties;
    }

    return { ...newProperties,
      [key]: value
    };
  }, {});
}

function getGroups(field, editField) {
  if (!field) {
    return [];
  }

  const groups = [GeneralGroup(field, editField), ...ValuesGroups(field, editField), ValidationGroup(field, editField), CustomValuesGroup(field, editField)]; // contract: if a group returns null, it should not be displayed at all

  return groups.filter(group => group !== null);
}

function FormPropertiesPanel(props) {
  const {
    eventBus,
    injector
  } = props;
  const formEditor = injector.get('formEditor');
  const modeling = injector.get('modeling');
  const selection = injector.get('selection');

  const {
    schema
  } = formEditor._getState();

  const [state, setState] = useState({
    selectedFormField: selection.get() || schema
  });

  const _update = field => {
    setState({ ...state,
      selectedFormField: field
    }); // notify interested parties on property panel updates

    eventBus.fire('propertiesPanel.updated', {
      formField: field
    });
  };

  useLayoutEffect(() => {
    function onSelectionChange(event) {
      _update(event.selection || schema);
    }

    eventBus.on('selection.changed', onSelectionChange);
    return () => {
      eventBus.off('selection.changed', onSelectionChange);
    };
  }, []);
  useLayoutEffect(() => {
    const onFieldChanged = () => {
      /**
       * TODO(pinussilvestrus): update with actual updated element,
       * once we have a proper updater/change support
       */
      _update(selection.get() || schema);
    };

    eventBus.on('changed', onFieldChanged);
    return () => {
      eventBus.off('changed', onFieldChanged);
    };
  }, []);
  const selectedFormField = state.selectedFormField;
  const propertiesPanelContext = {
    getService(type, strict = true) {
      return injector.get(type, strict);
    }

  };

  const onFocus = () => eventBus.fire('propertiesPanel.focusin');

  const onBlur = () => eventBus.fire('propertiesPanel.focusout');

  const editField = useCallback((formField, key, value) => modeling.editFormField(formField, key, value), [modeling]);
  return jsx("div", {
    class: "fjs-properties-panel",
    "data-field": selectedFormField && selectedFormField.id,
    onFocusCapture: onFocus,
    onBlurCapture: onBlur,
    children: jsx(PropertiesPanelContext.Provider, {
      value: propertiesPanelContext,
      children: jsx(PropertiesPanel, {
        element: selectedFormField,
        eventBus: eventBus,
        groups: getGroups(selectedFormField, editField),
        headerProvider: PropertiesPanelHeaderProvider,
        placeholderProvider: PropertiesPanelPlaceholderProvider
      })
    })
  });
}

class PropertiesPanelRenderer {
  constructor(propertiesPanelConfig, injector, eventBus) {
    const {
      parent
    } = propertiesPanelConfig || {};
    this._eventBus = eventBus;
    this._injector = injector;
    this._container = domify('<div class="fjs-properties-container" input-handle-modified-keys="y,z"></div>');

    if (parent) {
      this.attachTo(parent);
    }

    this._eventBus.once('formEditor.rendered', 500, () => {
      this._render();
    });
  }
  /**
   * Attach the properties panel to a parent node.
   *
   * @param {HTMLElement} container
   */


  attachTo(container) {
    if (!container) {
      throw new Error('container required');
    }

    if (typeof container === 'string') {
      container = query(container);
    } // (1) detach from old parent


    this.detach(); // (2) append to parent container

    container.appendChild(this._container); // (3) notify interested parties

    this._eventBus.fire('propertiesPanel.attach');
  }
  /**
   * Detach the properties panel from its parent node.
   */


  detach() {
    const parentNode = this._container.parentNode;

    if (parentNode) {
      parentNode.removeChild(this._container);

      this._eventBus.fire('propertiesPanel.detach');
    }
  }

  _render() {
    render(jsx(FormPropertiesPanel, {
      eventBus: this._eventBus,
      injector: this._injector
    }), this._container);

    this._eventBus.fire('propertiesPanel.rendered');
  }

  _destroy() {
    if (this._container) {
      render(null, this._container);

      this._eventBus.fire('propertiesPanel.destroyed');
    }
  }

}
PropertiesPanelRenderer.$inject = ['config.propertiesPanel', 'injector', 'eventBus'];

var PropertiesPanelModule = {
  __init__: ['propertiesPanel'],
  propertiesPanel: ['type', PropertiesPanelRenderer]
};

const ids = new Ids([32, 36, 1]);
/**
 * @typedef { import('./types').Injector } Injector
 * @typedef { import('./types').Module } Module
 * @typedef { import('./types').Schema } Schema
 *
 * @typedef { import('./types').FormEditorOptions } FormEditorOptions
 * @typedef { import('./types').FormEditorProperties } FormEditorProperties
 *
 * @typedef { {
 *   properties: FormEditorProperties,
 *   schema: Schema
 * } } State
 *
 * @typedef { (type:string, priority:number, handler:Function) => void } OnEventWithPriority
 * @typedef { (type:string, handler:Function) => void } OnEventWithOutPriority
 * @typedef { OnEventWithPriority & OnEventWithOutPriority } OnEventType
 */

/**
 * The form editor.
 */

class FormEditor {
  /**
   * @constructor
   * @param {FormEditorOptions} options
   */
  constructor(options = {}) {
    /**
     * @public
     * @type {OnEventType}
     */
    this.on = this._onEvent;
    /**
     * @public
     * @type {String}
     */

    this._id = ids.next();
    /**
     * @private
     * @type {Element}
     */

    this._container = createFormContainer();

    this._container.setAttribute('input-handle-modified-keys', 'z,y');

    const {
      container,
      exporter,
      injector = this._createInjector(options, this._container),
      properties = {}
    } = options;
    /**
     * @private
     * @type {any}
     */

    this.exporter = exporter;
    /**
     * @private
     * @type {State}
     */

    this._state = {
      properties,
      schema: null
    };
    this.get = injector.get;
    this.invoke = injector.invoke;
    this.get('eventBus').fire('form.init');

    if (container) {
      this.attachTo(container);
    }
  }

  clear() {
    // clear form services
    this._emit('diagram.clear'); // clear diagram services (e.g. EventBus)


    this._emit('form.clear');
  }

  destroy() {
    // destroy form services
    this.get('eventBus').fire('form.destroy'); // destroy diagram services (e.g. EventBus)

    this.get('eventBus').fire('diagram.destroy');

    this._detach(false);
  }
  /**
   * @param {Schema} schema
   *
   * @return {Promise<{ warnings: Array<any> }>}
   */


  importSchema(schema) {
    return new Promise((resolve, reject) => {
      try {
        this.clear();
        const {
          schema: importedSchema,
          warnings
        } = this.get('importer').importSchema(schema);

        this._setState({
          schema: importedSchema
        });

        this._emit('import.done', {
          warnings
        });

        return resolve({
          warnings
        });
      } catch (error) {
        this._emit('import.done', {
          error: error,
          warnings: error.warnings || []
        });

        return reject(error);
      }
    });
  }
  /**
   * @returns {Schema}
   */


  saveSchema() {
    return this.getSchema();
  }
  /**
   * @returns {Schema}
   */


  getSchema() {
    const {
      schema
    } = this._getState();

    return exportSchema(schema, this.exporter, schemaVersion);
  }
  /**
   * @param {Element|string} parentNode
   */


  attachTo(parentNode) {
    if (!parentNode) {
      throw new Error('parentNode required');
    }

    this.detach();

    if (isString(parentNode)) {
      parentNode = document.querySelector(parentNode);
    }

    const container = this._container;
    parentNode.appendChild(container);

    this._emit('attach');
  }

  detach() {
    this._detach();
  }
  /**
   * @internal
   *
   * @param {boolean} [emit]
   */


  _detach(emit = true) {
    const container = this._container,
          parentNode = container.parentNode;

    if (!parentNode) {
      return;
    }

    if (emit) {
      this._emit('detach');
    }

    parentNode.removeChild(container);
  }
  /**
   * @param {any} property
   * @param {any} value
   */


  setProperty(property, value) {
    const properties = set(this._getState().properties, [property], value);

    this._setState({
      properties
    });
  }
  /**
   * @param {string} type
   * @param {Function} handler
   */


  off(type, handler) {
    this.get('eventBus').off(type, handler);
  }
  /**
   * @internal
   *
   * @param {FormEditorOptions} options
   * @param {Element} container
   *
   * @returns {Injector}
   */


  _createInjector(options, container) {
    const {
      additionalModules = [],
      modules = this._getModules(),
      renderer = {}
    } = options;
    const config = { ...options,
      renderer: { ...renderer,
        container
      }
    };
    return createInjector([{
      config: ['value', config]
    }, {
      formEditor: ['value', this]
    }, core, ...modules, ...additionalModules]);
  }
  /**
   * @internal
   */


  _emit(type, data) {
    this.get('eventBus').fire(type, data);
  }
  /**
   * @internal
   */


  _getState() {
    return this._state;
  }
  /**
   * @internal
   */


  _setState(state) {
    this._state = { ...this._state,
      ...state
    };

    this._emit('changed', this._getState());
  }
  /**
   * @internal
   */


  _getModules() {
    return [ModelingModule, EditorActionsModule, KeyboardModule, SelectionModule, PaletteModule, PropertiesPanelModule];
  }
  /**
   * @internal
   */


  _onEvent(type, priority, handler) {
    this.get('eventBus').on(type, priority, handler);
  }

} // helpers //////////

function exportSchema(schema, exporter, schemaVersion) {
  const exportDetails = exporter ? {
    exporter
  } : {};
  const cleanedSchema = clone(schema, (name, value) => {
    if (['_parent', '_path'].includes(name)) {
      return undefined;
    }

    return value;
  });
  return { ...cleanedSchema,
    ...exportDetails,
    schemaVersion
  };
}

/**
 * @typedef { import('./types').CreateFormEditorOptions } CreateFormEditorOptions
 */

/**
 * Create a form editor.
 *
 * @param {CreateFormEditorOptions} options
 *
 * @return {Promise<FormEditor>}
 */

function createFormEditor(options) {
  const {
    schema,
    ...rest
  } = options;
  const formEditor = new FormEditor(rest);
  return formEditor.importSchema(schema).then(() => {
    return formEditor;
  });
}

export { FormEditor, createFormEditor };
//# sourceMappingURL=index.es.js.map
