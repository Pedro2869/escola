import { render } from 'preact';
import fileDrop from 'file-drops';
import mitt from 'mitt';
import { useEffect, useRef, useState, useCallback } from 'preact/hooks';
import download from 'downloadjs';
import classNames from 'classnames';
import { Form } from '@bpmn-io/form-js-viewer';
import { FormEditor } from '@bpmn-io/form-js-editor';
import { jsxs, jsx } from 'preact/jsx-runtime';
import { basicSetup } from 'codemirror';
import { EditorView } from '@codemirror/view';
import { Compartment, EditorState } from '@codemirror/state';
import { json } from '@codemirror/lang-json';

function Modal(props) {
  useEffect(() => {
    function handleKey(event) {
      if (event.key === 'Escape') {
        event.stopPropagation();
        props.onClose();
      }
    }

    document.addEventListener('keydown', handleKey);
    return () => {
      document.removeEventListener('keydown', handleKey);
    };
  });
  return jsxs("div", {
    class: "fjs-pgl-modal",
    children: [jsx("div", {
      class: "fjs-pgl-modal-backdrop",
      onClick: props.onClose
    }), jsxs("div", {
      class: "fjs-pgl-modal-content",
      children: [jsx("h1", {
        class: "fjs-pgl-modal-header",
        children: props.name
      }), jsx("div", {
        class: "fjs-pgl-modal-body",
        children: props.children
      }), jsx("div", {
        class: "fjs-pgl-modal-footer",
        children: jsx("button", {
          class: "fjs-pgl-button fjs-pgl-button-default",
          onClick: props.onClose,
          children: "Close"
        })
      })]
    })]
  });
}

function EmbedModal(props) {
  const schema = serializeValue(props.schema);
  const data = serializeValue(props.data || {});
  const fieldRef = useRef();
  const snippet = `<!-- styles needed for rendering -->
<link rel="stylesheet" href="https://unpkg.com/@bpmn-io/form-js@0.2.4/dist/assets/form-js.css">

<!-- container to render the form into -->
<div class="fjs-pgl-form-container"></div>

<!-- scripts needed for embedding -->
<script src="https://unpkg.com/@bpmn-io/form-js@0.2.4/dist/form-viewer.umd.js"></script>

<!-- actual script to instantiate the form and load form schema + data -->
<script>
  const data = JSON.parse(${data});
  const schema = JSON.parse(${schema});

  const form = new FormViewer.Form({
    container: document.querySelector(".fjs-pgl-form-container")
  });

  form.on("submit", (event) => {
    console.log(event.data, event.errors);
  });

  form.importSchema(schema, data).catch(err => {
    console.error("Failed to render form", err);
  });
</script>
  `.trim();
  useEffect(() => {
    fieldRef.current.select();
  });
  return jsxs(Modal, {
    name: "Embed form",
    onClose: props.onClose,
    children: [jsxs("p", {
      children: ["Use the following HTML snippet to embed your form with ", jsx("a", {
        href: "https://github.com/bpmn-io/form-js",
        children: "form-js"
      }), ":"]
    }), jsx("textarea", {
      spellCheck: "false",
      ref: fieldRef,
      children: snippet
    })]
  });
} // helpers ///////////

function serializeValue(obj) {
  return JSON.stringify(JSON.stringify(obj)).replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function JSONEditor(options = {}) {
  const emitter = mitt();
  const {
    readonly = false
  } = options;
  let language = new Compartment().of(json());
  let tabSize = new Compartment().of(EditorState.tabSize.of(2));

  function createState(doc, extensions = []) {
    return EditorState.create({
      doc,
      extensions: [basicSetup, language, tabSize, ...extensions]
    });
  }

  function createView(readonly) {
    const updateListener = EditorView.updateListener.of(update => {
      if (update.docChanged) {
        emitter.emit('changed', {
          value: update.view.state.doc.toString()
        });
      }
    });
    const editable = EditorView.editable.of(!readonly);
    const view = new EditorView({
      state: createState('', [updateListener, editable])
    });

    view.setValue = function (value) {
      this.setState(createState(value, [updateListener, editable]));
    };

    return view;
  }

  const view = createView(readonly);

  this.setValue = function (value) {
    view.setValue(value);
  };

  this.getValue = function () {
    return view.state.doc.toString();
  };

  this.on = emitter.on;
  this.off = emitter.off;

  this.attachTo = function (container) {
    container.appendChild(view.dom);
  };

  this.destroy = function () {
    if (view.dom.parentNode) {
      view.dom.parentNode.removeChild(view.dom);
    }

    view.destroy();
  };
}

function Section(props) {
  const elements = Array.isArray(props.children) ? props.children : [props.children];
  const {
    headerItems,
    children
  } = elements.reduce((_, child) => {
    const bucket = child.type === Section.HeaderItem ? _.headerItems : _.children;
    bucket.push(child);
    return _;
  }, {
    headerItems: [],
    children: []
  });
  return jsxs("div", {
    class: "fjs-pgl-section",
    children: [jsxs("h1", {
      class: "header",
      children: [props.name, " ", headerItems.length ? jsx("span", {
        class: "header-items",
        children: headerItems
      }) : null]
    }), jsx("div", {
      class: "body",
      children: children
    })]
  });
}

Section.HeaderItem = function (props) {
  return props.children;
};

function PlaygroundRoot(props) {
  const {
    actions: actionsConfig = {},
    editor: editorConfig = {},
    emit,
    exporter: exporterConfig = {}
  } = props;
  const {
    display: displayActions = true
  } = actionsConfig;
  const {
    inlinePropertiesPanel = true
  } = editorConfig;
  const paletteContainerRef = useRef();
  const editorContainerRef = useRef();
  const formContainerRef = useRef();
  const dataContainerRef = useRef();
  const resultContainerRef = useRef();
  const propertiesPanelContainerRef = useRef();
  const paletteRef = useRef();
  const formEditorRef = useRef();
  const formRef = useRef();
  const dataEditorRef = useRef();
  const resultViewRef = useRef();
  const propertiesPanelRef = useRef();
  const [showEmbed, setShowEmbed] = useState(false);
  const [initialData] = useState(props.data || {});
  const [initialSchema, setInitialSchema] = useState(props.schema);
  const [data, setData] = useState(props.data || {});
  const [schema, setSchema] = useState(props.schema);
  const [resultData, setResultData] = useState(props.data || {}); // pipe to playground API

  useEffect(() => {
    props.onInit({
      attachDataContainer: node => dataEditorRef.current.attachTo(node),
      attachEditorContainer: node => formEditorRef.current.attachTo(node),
      attachFormContainer: node => formRef.current.attachTo(node),
      attachPaletteContainer: node => paletteRef.current.attachTo(node),
      attachPropertiesPanelContainer: node => propertiesPanelRef.current.attachTo(node),
      attachResultContainer: node => resultViewRef.current.attachTo(node),
      get: (name, strict) => formEditorRef.current.get(name, strict),
      getEditor: () => formEditorRef.current,
      getSchema: () => formEditorRef.current.getSchema(),
      setSchema: setInitialSchema,
      saveSchema: () => formEditorRef.current.saveSchema()
    });
  });
  useEffect(() => {
    setInitialSchema(props.schema || {});
  }, [props.schema]);
  useEffect(() => {
    const dataEditor = dataEditorRef.current = new JSONEditor({
      value: toJSON(data)
    });
    const resultView = resultViewRef.current = new JSONEditor({
      readonly: true,
      value: toJSON(resultData)
    });
    const form = formRef.current = new Form();
    const formEditor = formEditorRef.current = new FormEditor({
      renderer: {
        compact: true
      },
      palette: {
        parent: paletteContainerRef.current
      },
      propertiesPanel: {
        parent: !inlinePropertiesPanel && propertiesPanelContainerRef.current
      },
      exporter: exporterConfig
    });
    paletteRef.current = formEditor.get('palette');
    propertiesPanelRef.current = formEditor.get('propertiesPanel');
    formEditor.on('changed', () => {
      setSchema(formEditor.getSchema());
    });
    formEditor.on('formEditor.rendered', () => {
      // notifiy interested parties after render
      emit('formPlayground.rendered');
    });
    form.on('changed', event => {
      setResultData(event.data);
    });
    dataEditor.on('changed', event => {
      try {
        setData(JSON.parse(event.value));
      } catch (err) {// TODO(nikku): indicate JSON parse error
      }
    });
    const formContainer = formContainerRef.current;
    const editorContainer = editorContainerRef.current;
    const dataContainer = dataContainerRef.current;
    const resultContainer = resultContainerRef.current;
    dataEditor.attachTo(dataContainer);
    resultView.attachTo(resultContainer);
    form.attachTo(formContainer);
    formEditor.attachTo(editorContainer);
    return () => {
      dataEditor.destroy();
      resultView.destroy();
      form.destroy();
      formEditor.destroy();
    };
  }, []);
  useEffect(() => {
    dataEditorRef.current.setValue(toJSON(initialData));
  }, [initialData]);
  useEffect(() => {
    initialSchema && formEditorRef.current.importSchema(initialSchema);
  }, [initialSchema]);
  useEffect(() => {
    schema && formRef.current.importSchema(schema, data);
  }, [schema, data]);
  useEffect(() => {
    resultViewRef.current.setValue(toJSON(resultData));
  }, [resultData]);
  useEffect(() => {
    props.onStateChanged({
      schema,
      data
    });
  }, [schema, data]);
  const handleDownload = useCallback(() => {
    download(JSON.stringify(schema, null, '  '), 'form.json', 'text/json');
  }, [schema]);
  const hideEmbedModal = useCallback(() => {
    setShowEmbed(false);
  }, []);
  const showEmbedModal = useCallback(() => {
    setShowEmbed(true);
  }, []);
  return jsxs("div", {
    class: classNames('fjs-container', 'fjs-pgl-root', {
      'fjs-pgl-inline-editor-panel': inlinePropertiesPanel
    }),
    children: [jsx("div", {
      class: "fjs-pgl-modals",
      children: showEmbed ? jsx(EmbedModal, {
        schema: schema,
        data: data,
        onClose: hideEmbedModal
      }) : null
    }), jsx("div", {
      class: "fjs-pgl-palette-container",
      ref: paletteContainerRef
    }), jsxs("div", {
      class: "fjs-pgl-main",
      children: [jsxs(Section, {
        name: "Form Definition",
        children: [displayActions && jsx(Section.HeaderItem, {
          children: jsx("button", {
            class: "fjs-pgl-button",
            title: "Download form definition",
            onClick: handleDownload,
            children: "Download"
          })
        }), displayActions && jsx(Section.HeaderItem, {
          children: jsx("button", {
            class: "fjs-pgl-button",
            onClick: showEmbedModal,
            children: "Embed"
          })
        }), jsx("div", {
          ref: editorContainerRef,
          class: "fjs-pgl-form-container"
        })]
      }), jsx(Section, {
        name: "Form Preview",
        children: jsx("div", {
          ref: formContainerRef,
          class: "fjs-pgl-form-container"
        })
      }), jsx(Section, {
        name: "Form Data (Input)",
        children: jsx("div", {
          ref: dataContainerRef,
          class: "fjs-pgl-text-container"
        })
      }), jsx(Section, {
        name: "Form Data (Submit)",
        children: jsx("div", {
          ref: resultContainerRef,
          class: "fjs-pgl-text-container"
        })
      })]
    }), jsx("div", {
      class: "fjs-pgl-properties-container",
      ref: propertiesPanelContainerRef
    })]
  });
} // helpers ///////////////

function toJSON(obj) {
  return JSON.stringify(obj, null, '  ');
}

function Playground(options) {
  const {
    container: parent,
    schema,
    data,
    ...rest
  } = options;
  const emitter = mitt();
  let state = {
    data,
    schema
  };
  let ref;
  const container = document.createElement('div');
  container.classList.add('fjs-pgl-parent');

  if (parent) {
    parent.appendChild(container);
  }

  const handleDrop = fileDrop('Drop a form file', function (files) {
    const file = files[0];

    if (file) {
      try {
        ref.setSchema(JSON.parse(file.contents));
      } catch (err) {// TODO(nikku): indicate JSON parse error
      }
    }
  });

  const withRef = function (fn) {
    return function (...args) {
      if (!ref) {
        throw new Error('Playground is not initialized.');
      }

      return fn(...args);
    };
  };

  const onInit = function (_ref) {
    ref = _ref;
    emitter.emit('formPlayground.init');
  };

  container.addEventListener('dragover', handleDrop);
  render(jsx(PlaygroundRoot, {
    data: data,
    emit: emitter.emit,
    onInit: onInit,
    onStateChanged: _state => state = _state,
    schema: schema,
    ...rest
  }), container);
  this.on = emitter.on;
  this.off = emitter.off;
  this.emit = emitter.emit;
  this.on('destroy', function () {
    render(null, container);
  });
  this.on('destroy', function () {
    parent.removeChild(container);
  });

  this.getState = function () {
    return state;
  };

  this.getSchema = withRef(function () {
    return ref.getSchema();
  });
  this.setSchema = withRef(function (schema) {
    return ref.setSchema(schema);
  });
  this.saveSchema = withRef(function () {
    return ref.saveSchema();
  });
  this.get = withRef(function (name, strict) {
    return ref.get(name, strict);
  });
  this.getEditor = withRef(function () {
    return ref.getEditor();
  });

  this.destroy = function () {
    this.emit('destroy');
  };

  this.attachEditorContainer = withRef(function (node) {
    return ref.attachEditorContainer(node);
  });
  this.attachPreviewContainer = withRef(function (node) {
    return ref.attachFormContainer(node);
  });
  this.attachDataContainer = withRef(function (node) {
    return ref.attachDataContainer(node);
  });
  this.attachResultContainer = withRef(function (node) {
    return ref.attachResultContainer(node);
  });
  this.attachPaletteContainer = withRef(function (node) {
    return ref.attachPaletteContainer(node);
  });
  this.attachPropertiesPanelContainer = withRef(function (node) {
    return ref.attachPropertiesPanelContainer(node);
  });
}

export { Playground };
//# sourceMappingURL=index.es.js.map
